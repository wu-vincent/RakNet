---
title: "Creating Packets"
description: "How to encode game data into network packets using either C structs or the BitStream class."
---

## Encoding game data into packets

Systems running RakNet, and all systems on the internet, communicate through packets -- or more accurately in the case of UDP, datagrams. Each datagram is created by RakNet and contains one or more messages. Messages can be created by you (such as position or health) or by RakNet internally (such as pings). By convention, the first byte of a message contains a numerical identifier from 0 to 255 indicating the message type. RakNet already uses a large set of message identifiers internally and for plugins. These are defined in `MessageIdentifiers.h`.

For this example, suppose you need to set the position of a timed mine in the game world. You need the following data:

-   The position of the mine: 3 floats (`x`, `y`, `z`). You may have your own vector type to use instead.
-   A way to refer to the mine that all systems agree on. The [`NetworkIDObject`](/basics/network-id-object) class is ideal. Assume class `Mine` inherits from `NetworkIDObject`; you store the `NetworkID` of the mine (see [Receiving Packets](/basics/receiving-packets), [Sending Packets](/basics/sending-packets)).
-   The mine owner, so credit goes to the correct player when someone steps on it. The built-in `SystemAddress` reference works well here. Use `GetExternalID()` to get the `SystemAddress`.
-   When the mine was placed. Suppose that after 10 seconds the mine automatically disintegrates -- getting the time correct is important so the mine does not disintegrate at different times on different computers. RakNet handles this with [Timestamping](/basics/timestamping).

## Structure or BitStream?

Any data you send ultimately goes as a stream of characters. There are two straightforward ways to encode your data. One is to create a structure and cast it to `(char*)`; the other is to use the built-in [BitStream](/basics/bitstreams) class.

The advantage of creating a structure and casting is that it is very easy to change the structure and to see what data you are actually sending. Since both the sender and the recipient can share the same source file defining the structure, you avoid casting mistakes. There is also no risk of getting the data out of order, or using the wrong types. The disadvantage of creating a structure is that you often have to change and recompile many files to do so. You lose the compression you can automatically perform with the bitstream class. And RakNet cannot automatically endian-swap the structure members.

The advantage of using a bitstream is that you do not need to change any external files. Create the bitstream, write the data in whatever order you want, and send it. You can use the compressed versions of the read and write methods to write using fewer bits, and bools are written using only one bit. You can write data dynamically, writing certain values only if certain conditions are true or false. BitStream automatically endian-swaps members written with `Serialize()`, `Write()`, or `Read()`. The disadvantage is susceptibility to mistakes: you can read data in a way that does not complement how you wrote it -- wrong order, wrong data type, or other mismatches.

Both approaches are covered below.

<Tabs items={["Struct", "BitStream"]}>
<Tab value="Struct">

## Creating Packets with structs

As mentioned earlier, RakNet uses a convention on how packet (Packet) types are identified. The first byte of the data field is a single byte enumeration that specifies type, followed by the transmitted data. In packets that include a time stamp, the first byte contains ID_TIMESTAMP, the following 4 bytes the actual time stamp value, then the byte that identifies the packet, and only then the actual data transmitted.

### Without Timestamping

```cpp
#pragma pack(push, 1)
struct structName {
    unsigned char typeId; // Your type here
    // Your data here
};
#pragma pack(pop)
```

The `#pragma pack(push,1)` and `#pragma pack(pop)` directives force the compiler (VC++ in this case) to pack the structure as byte-aligned. Check your compiler documentation for details.

### With Timestamping

```cpp
#pragma pack(push, 1)
struct structName {
    unsigned char useTimeStamp; // Assign ID_TIMESTAMP to this
    RakNet::Time timeStamp;     // Put the system time in here returned by RakNet::GetTime()
                                // or some other method that returns a similar value
    unsigned char typeId;       // Your type here
    // Your data here
};
#pragma pack(pop)
```

When sending structures, RakNet assumes `timeStamp` is in network order. Use `BitStream::EndianSwapBytes()` on the `timeStamp` field to ensure this. To read the timestamp on the receiving system, use `if (bitStream->DoEndianSwap()) bitStream->ReverseBytes(timeStamp, sizeof(timeStamp)`. This step is not necessary when using BitStreams.

Fill out your packet. For the timed mine, you want the form that uses timestamping. The result looks like this:

```cpp
#pragma pack(push, 1)
struct structName {
    unsigned char useTimeStamp;  // Assign ID_TIMESTAMP to this
    RakNet::Time timeStamp;      // Put the system time in here returned by RakNet::GetTime()
    unsigned char typeId;        // You should put here an enum you defined after the last one
                                 // defined in MessageIdentifiers.h, lets say ID_SET_TIMED_MINE
    float x, y, z;               // Mine position
    NetworkID networkId;         // NetworkID of the mine, used as a common method to
                                 // refer to the mine on different computers
    SystemAddress systemAddress; // The SystemAddress of the player that owns the mine
};
#pragma pack(pop)
```

As noted in the comment above, you must define enums for your own packet types so that when data arrives in a `Receive` call you can identify it. Define your enums starting at `ID_USER_PACKET_ENUM`:

```cpp
// Define our custom packet ID's
enum {
    ID_SET_TIMED_MINE = ID_USER_PACKET_ENUM,
    // More enums....
};
```

<Callout type="error">
**You cannot include pointers directly or indirectly in the structs.** It is a fairly common mistake to include a pointer or a class with a pointer in the struct and think that the data pointed to by the pointer will be sent over the network. This is not the case -- all it would send is the pointer address.
</Callout>

### Nested Structures

Nesting structures is fine. Keep in mind that the first byte always determines the packet type.

```cpp
#pragma pack(push, 1)
struct A {
    unsigned char typeId; // ID_A
};
struct B {
    unsigned char typeId; // ID_A
};
struct C // Struct C is of type ID_A
{
    A a;
    B b;
};
struct D // Struct D is of type ID_B
{
    B b;
    A a;
};
#pragma pack(pop)
```

</Tab>
<Tab value="BitStream">

## Creating Packets with Bitstreams

### Write less data with BitStreams

Take the mine example above and use a bitstream to write it out instead. All the same data applies.

```cpp
MessageID useTimeStamp; // Assign this to ID_TIMESTAMP
RakNet::Time timeStamp; // Put the system time in here returned by RakNet::GetTime()
MessageID typeId;       // This will be assigned to a type I've added after
                        // ID_USER_PACKET_ENUM, lets say ID_SET_TIMED_MINE
useTimeStamp = ID_TIMESTAMP;
timeStamp = RakNet::GetTime();
typeId = ID_SET_TIMED_MINE;
Bitstream myBitStream;
myBitStream.Write(useTimeStamp);
myBitStream.Write(timeStamp);
myBitStream.Write(typeId);
// Assume we have a Mine* mine object
myBitStream.Write(mine->GetPosition().x);
myBitStream.Write(mine->GetPosition().y);
myBitStream.Write(mine->GetPosition().z);
myBitStream.Write(mine->GetNetworkID()); // In the struct this is NetworkID networkId
myBitStream.Write(mine->GetOwner());     // In the struct this is SystemAddress systemAddress
```

If you send `myBitStream` to `RakPeerInterface::Send`, it is identical internally to a casted struct at this point. Now consider some improvements. Suppose that mines are frequently at 0,0,0. You can then do this instead:

```cpp
unsigned char useTimeStamp; // Assign this to ID_TIMESTAMP
RakNet::Time timeStamp;     // Put the system time in here returned by RakNet::GetTime()
unsigned char typeId;       // This will be assigned to a type I've added after
                            // ID_USER_PACKET_ENUM, lets say ID_SET_TIMED_MINE
useTimeStamp = ID_TIMESTAMP;
timeStamp = RakNet::GetTime();
typeId = ID_SET_TIMED_MINE;
Bitstream myBitStream;
myBitStream.Write(useTimeStamp);
myBitStream.Write(timeStamp);
myBitStream.Write(typeId);
// Assume we have a Mine* mine object
// If the mine is at 0,0,0, use 1 bit to represent this
if (mine->GetPosition().x == 0.0f && mine->GetPosition().y == 0.0f &&
    mine->GetPosition().z == 0.0f) {
    myBitStream.Write(true);
} else {
    myBitStream.Write(false);
    myBitStream.Write(mine->GetPosition().x);
    myBitStream.Write(mine->GetPosition().y);
    myBitStream.Write(mine->GetPosition().z);
}
myBitStream.Write(mine->GetNetworkID()); // In the struct this is NetworkID networkId
myBitStream.Write(mine->GetOwner());     // In the struct this is SystemAddress systemAddress
```

This can potentially save sending 3 floats over the network, at the cost of 1 bit.

<Callout type="error">
**Common mistake:** When writing the first byte to a bitstream, cast it to `(MessageID)` or `(unsigned char)`. If you write the enumeration directly, you write a full integer (4 bytes).

Right: `bitStream->Write((MessageID)ID_SET_TIMED_MINE);`

Wrong: `bitStream->Write(ID_SET_TIMED_MINE);`

In the second case, RakNet will see the first byte is 0, which is reserved internally to `ID_INTERNAL_PING`, and you will never get it.
</Callout>

</Tab>
</Tabs>

## Writing strings

You can write strings using the array overload of the BitStream. One approach is to write the length, then the data:

```cpp
void WriteStringToBitStream(char *myString, BitStream *output) {
    output->Write((unsigned short)strlen(myString));
    output->Write(myString, strlen(myString));
}
```

Decoding is similar, but not very efficient. RakNet provides a built-in `StringCompressor` via the global instance `stringCompressor`. With it, `WriteStringToBitStream` becomes:

```cpp
void WriteStringToBitStream(char *myString, BitStream *output) {
    stringCompressor->EncodeString(myString, 256, output);
}
```

This both encodes the string (so it cannot be easily read by packet sniffers) and compresses it. To decode the string:

```cpp
void WriteBitStreamToString(char *myString, BitStream *input) {
    stringCompressor->DecodeString(myString, 256, input);
}
```

The 256 is the maximum number of bytes to write and read. In `EncodeString`, if your string is shorter than 256 characters, the entire string is written. If it is longer, it is truncated so that it decodes to an array of 256 characters, including the null terminator.

RakNet also has a string class, `RakNet::RakString`, found in `RakString.h`

```cpp
RakNet::RakString rakString("The value is %i", myInt);
```

```cpp
bitStream->write(rakString);
```

`RakString` is approximately 3X faster than `std::string`.

Use `RakWString` for Unicode support.

_Programmer's notes:_

1. You can also write structs directly into a `BitStream` by casting to `(char*)`. It copies your structs using `memcpy`. As with structs, it does not dereference pointers, so do not write pointers into the bitstream.
2. If you use a string very commonly, you can use the `StringTable` class instead. It works the same way as `StringCompressor`, but can send two bytes to represent a known string.

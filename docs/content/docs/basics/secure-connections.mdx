---
title: "Secure Connections"
description: "How to enable 256-bit Elliptic Curve encrypted connections in RakNet with key generation, setup, and error handling."
---

## Secure your network traffic

Once your online game reaches a certain popularity, people will try to cheat. You need to account for this at both the game layer and the network layer. RakNet handles the network layer by providing secure connections.

RakNet provides data security on par with 256-bit TLS. An efficient 256-bit Elliptic Curve key agreement with forward secrecy protects each connection with the server.

-   Cookies: Uses stateless cookie in the handshake, analogous to SYN cookies, that ensures the remote IP address is not spoofed
-   Efficient: Modern techniques published and improved in the last 2 years are employed to offer security without a performance penalty.
-   Forward secrecy: Uses Tunnel Key Agreement "Tabby" protocol. If the server is compromised at some point in the future, previously exchanged data cannot be decrypted.
-   Protection: Each message is encrypted and stamped with a message authentication code (MAC) and unique identifier to protect sensitive data and prevent replays.
-   Immune to active attacks (man-in-the-middle) if server key is known ahead of time
-   Uses 256-bit Elliptic Curve Cryptography
-   Elliptic Curve: Over finite field Fp, p = 2^n - c, c small
         Shape of curve: a' * x^2 + y^2 = 1 + d' * x^2 * y^2, a' = -1 (square in Fp)
         d' (non square in Fp) -> order of curve = q * cofactor h, order of generator point = q
         Curves satisfy MOV conditions and are not anomalous
         Point operations performed with Extended Twisted Edwards group laws

Secure connections add up to 11 bytes per packet and take time to compute, so you may wish to limit usage to release mode.

## Setup

<Steps>

<Step>

### Enable the LIBCAT_SECURITY define

Add `#define LIBCAT_SECURITY 1` to "NativeFeatureIncludesOverrides.h". Rebuild all.

</Step>

<Step>

### Include the secure handshake header

Include "Source/SecureHandshake.h". **DO NOT INCLUDE ANY FILES FROM Source/cat**

</Step>

<Step>

### Generate public and private keys

Create the public and private keys in advance:

```cpp
cat::EasyHandshake::Initialize();
cat::EasyHandshake handshake;
char public_key[cat::EasyHandshake::PUBLIC_KEY_BYTES];
char private_key[cat::EasyHandshake::PRIVATE_KEY_BYTES];
handshake.GenerateServerKey(public_key, private_key);
```

</Step>

<Step>

### Save keys to disk

Save the public and private keys to disk:

```cpp
fwrite(private_key, sizeof(private_key), 1, fp);
fwrite(public_key, sizeof(public_key), 1, fp);
```

</Step>

<Step>

### Configure the server

Load the public and private keys on the server, and pass them to `RakPeerInterface::InitializeSecurity()`.

<Callout type="warn">
Do not distribute the private key. It should remain secret on the server only.
</Callout>

</Step>

<Step>

### Configure the client

Load the public key on the client. Distribute the public key with the client application, or download it from a secure location. Pass the public key to `RakPeerInterface::Connect()`.

</Step>

<Step>

### Connect

Connect the server to the client as usual.

</Step>

</Steps>

<Callout type="error">
Possible errors, returned in `packet->data[0]`:

- **ID_REMOTE_SYSTEM_REQUIRES_PUBLIC_KEY**: You didn't pass a public key to `RakPeerInterface::Connect()`.
- **ID_OUR_SYSTEM_REQUIRES_SECURITY**: You did pass a public key to `RakPeerInterface::Connect()`, but `InitializeSecurity()` was not called on the server.
- **ID_PUBLIC_KEY_MISMATCH**: The public key on the client does not match the public key on the server.
</Callout>

## Public key transmission

Generate the public key on a remote system in advance of connecting to that system. The public key identifies the remote system, so you know the system that replied is the one you are actually trying to connect to. An attacker might know the public key, but without the private key (which you keep secret), they cannot establish a connection with you.

For peer-to-peer, run a dedicated server that is itself secure. Distribute the client with the public key to that server known in advance. Connect to that server, upload the peer's public key into a database, and wait for incoming connections. When a peer wants to connect, it connects to that server, downloads the public key for the target peer, and uses that public key for the connection.

Alternate solutions:

1.  Use PHPDirectoryServer to pass the public keys. While not secure, it works with a PHP-enabled webhost (typically $5 to $10 a month) and is more secure than option 2.
2.  In `RakPeer::Connect`, pass `true` for `acceptAnyPublicKey` in the `publicKey` parameter. This is similar to RakNet version 3 where you pass `0` for each parameter to `InitializeSecurity`. In this case, transmitting the public key in advance is not necessary.

See the sample at _Samples/Encryption_ for a working example.

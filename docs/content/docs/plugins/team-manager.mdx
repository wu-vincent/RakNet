---
title: "TeamManager"
description: "Manage teams and team members with support for join conditions, locking, resizing, buffered requests, and full replication across all systems."
---

### Manages lists of teams and team members. Supports client/server and peer to peer

`TeamManager` reduces the work involved with managing teams and team members. Functionality includes:

-   Support for any number of teams with join conditions on each.
-   Support for team members being on multiple teams at the same time, or no team at all.
-   Support for independent worlds, enabling you to host multiple game sessions simultaneously.
-   The ability to lock, unlock, and resize teams.
-   Team requests for locked or full teams are buffered and filled in first-come first-served order, including the ability to swap teams.
-   The state of all teams and all team members are fully replicated to all systems.
-   Flexible architecture, with support for client/server, [ReplicaManager3](/plugins/replica-manager3) and the use of either composition or inheritance.

<Steps>
<Step>

### Define game classes

Define your game classes to represent teams and team members. Your game classes should hold game-specific information such as team name and color.

</Step>

<Step>

### Add TM_Team / TM_TeamMember instances

Have those game classes contain a corresponding `TM_Team` or `TM_TeamMember` instance. Operations on teams will be performed by those instances. Use `SetOwner()` to refer to the parent object when using composition.

</Step>

<Step>

### Set topology

Call `TeamManager::SetTopology()` for client/server or peer to peer.

</Step>

<Step>

### Add a world

Call `AddWorld()` to instantiate a `TM_World` object which will contain references to your `TM_TeamMember` and `TM_Team` instances.

</Step>

<Step>

### Reference teams and members

When you instantiate a `TM_TeamMember` or `TM_Team` object, call `ReferenceTeam()` and `ReferenceTeamMember()` for each corresponding object. If using `ReplicaManager3`, the Reference calls should be at the top of `DeserializeConstruction()`, as well as when creating the object locally.

</Step>

<Step>

### Serialize construction

When sending world state to a new connection, for example in `ReplicaManager3::SerializeConstruction()`, call `TM_SerializeConstruction()` on the corresponding `TM_TeamMember` and `TM_Team` objects. `TM_Team` instances on the new connection must be created before `TM_TeamMember` instances.

</Step>

<Step>

### Deserialize construction

Call `TM_DeserializeConstruction()` on your new corresponding `TM_TeamMember` and `TM_Team` instances.

</Step>

<Step>

### Execute team operations

Execute team operations. `ID_TEAM_BALANCER_REQUESTED_TEAM_FULL`, `ID_TEAM_BALANCER_REQUESTED_TEAM_LOCKED`, `ID_TEAM_BALANCER_TEAM_REQUESTED_CANCELLED`, and `ID_TEAM_BALANCER_TEAM_ASSIGNED` are returned to all systems when the corresponding event occurs for a team member.

</Step>

<Step>

### Handle host changes

As the peer to peer session host changes, call `SetHost()` (not necessary if using `FullyConnectedMesh2`). If using client/server, you must set the host.

</Step>

<Step>

### Order of deserialization

`DeserializeConstruction()` must be called on `TM_Team` before `DeserializeConstruction()` is called on `TM_TeamMember` that is a member of that team. If using `ReplicaManager3`, you can simply call `ReplicaManager3::Reference()` on `TM_TeamMember` later than any `ReplicaManager3::Reference()` calls to `TM_Team`.

</Step>
</Steps>

See the header file `TeamManager.h` for more information and complete documentation of each parameter and function, as well as messages returned to the user.

_See the sample project `Samples\TeamManager` for an implementation of this system._

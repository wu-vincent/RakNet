---
title: "Distributed Network Object"
description: "Automatically synchronize object creation, destruction, and member variables across all connected systems using the Distributed Network Object system."
---

<Callout type="warn">
**Deprecated:** This system has been superseded by [ReplicaManager3](/plugins/replica-manager3), which provides more flexible object replication.
</Callout>

### Overview of the distributed network object system

The distributed network object system is the highest level layer over RakNet. The concept is simple: objects that are instantiated on one system are instantiated on all systems. Objects that are destroyed on one system are destroyed on all systems. Tagged memory is matched between systems. When a new player connects, these objects are also created on his system.

This is very useful conceptually because it has a direct analogy to game objects. For example, one tank in a multiplayer game with twenty players has actually been instantiated twenty times. However, as far as the player is concerned there is only one tank. The player expects that the position, orientation, number of shells left, and amount of armor is the same on all systems.

Traditionally, to maintain a tank you would have to craft a series of custom packets for the tank. One packet to describe position, another for the tank to shoot, and another to have the tank take damage. Using the distributed network object system, you can synchronize the tank, those 3 member variables, and everything matches automatically.

**Strengths**

- Implementation only takes a minute and once it works it is foolproof.
- You don't have to worry about sending game data to new players.
- You don't have to worry about game objects getting out of synch.
- You don't care about the complexity of interactions between objects because you always get the correct final result.
- It is easy to network existing single player games.
- Interpolation is built-in.

**Weaknesses**

- Timestamping is not supported so you can't extrapolate position.
- Tracking the results of actions is less accurate than sending triggers that cause actions.
- Wasteful of bandwidth for predictable actions. For example, if a rocket shoots 20 cans this system requires 20 objects to receive data over time as the cans fall. With a packet you could describe only the rocket when it was launched and hence only do one send.
- Doesn't currently support arrays or pointers, although with arrays you can get around this by synchronizing each element or enclosing it in a structure.

Despite these weaknesses, this is the primary system in use by many games.

## How to implement

Before you can use the distributed object system, you have to register your instance of `RakClient` and/or `RakServer` with the Distributed Network Object Manager.

```cpp
DistributedNetworkObjectManager::Instance()->RegisterRakClientInterface(rakClient);
DistributedNetworkObjectManager::Instance()->RegisterRakServerInterface(rakServer);
```

The multiplayer class will automatically handle distributed object network messages. If you don't use the multiplayer class, you must handle these packet types yourself:

- `ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT`
- `ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_ACCEPTED`
- `ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_REJECTED`

You would pass them to the `DistributedNetworkObjectManager` in exactly the same fashion as is done in `Multiplayer.h`.

Once that is done, then you have several steps per class:

<Steps>
<Step>

### Add the header include

Add `#include "DistributedNetworkObjectHeader.h"` to the header file for your class.

</Step>

<Step>

### Derive from DistributedNetworkObject

The basemost class should derive from `DistributedNetworkObject`.

</Step>

<Step>

### Register the class

If you plan to instantiate this class, add `REGISTER_DISTRIBUTED_CLASS(ClassName)` in `main()` or `WinMain()`, with the name of your class replacing `ClassName`.

</Step>

<Step>

### Call UpdateDistributedObject

Once per game cycle call `objectInstance->UpdateDistributedObject(ClassName)` where `objectInstance` is the instance of your class and `ClassName` matches the identifier passed to `REGISTER_DISTRIBUTED_CLASS`.

</Step>
</Steps>

For example, if you want every instance of `Tank` to match among all systems:

```cpp
#include "DistributedNetworkObjectHeader.h"

class Tank : public DistributedNetworkObject
{
    // Your data and functions here
    // ...

    // The update function for the class is a good place to put UpdateDistributedObject
    void Update(void) { UpdateDistributedObject("Tank"); }
};

REGISTER_DISTRIBUTED_CLASS(Tank);
```

## Synchronized member variables

There are two ways to synchronize member variables:

1. **REGISTER_X_DISTRIBUTED_OBJECT_MEMBERS** preprocessor macro
2. **SynchronizeMemory** function

The macro supports automatic interpolation and requires only one line of code in your header file for all members. However, the declaration must match on all systems, variables cannot be added at runtime, and it doesn't support pointers or arrays.

The `SynchronizeMemory` function lets you add elements at runtime, members do not have to match, and it can support anything. However, it cannot perform interpolation, is more susceptible to user error, and requires one line of code per variable.

### The REGISTER_X_DISTRIBUTED_OBJECT_MEMBERS macro

In the public section of the class definition, add a macro of the form:

```cpp
REGISTER_X_DISTRIBUTED_OBJECT_MEMBERS(BaseClass,
    SynchronizationMethod, AuthoritativeNetwork, VariableType, VariableName,
    ...
)
```

Replace the `X` with however many member variables you are synchronizing (e.g. `REGISTER_3_DISTRIBUTED_OBJECT_MEMBERS` for 3 variables).

**SynchronizationMethod** values:

- `DOM_COPY_UNCOMPRESSED` -- Send the data without [bitstream compression](/basics/bitstreams) and copy over the old value on arrival. Useful for data such as player health.
- `DOM_COPY_COMPRESSED` -- Same as above but with bitstream compression. Useful for values that stay near 0. Only works with native types (char, int, short, long, float, bool).
- `DOM_INTERPOLATE_UNCOMPRESSED` -- No compression; interpolate from old value to new value on arrival. Requires the `+`, `-`, `*`, and `=` operators.
- `DOM_INTERPOLATE_COMPRESSED` -- Same with bitstream compression. Only works with native types. Requires the `+`, `-`, `*`, and `=` operators.

**AuthoritativeNetwork** values:

- `DOM_SERVER_AUTHORITATIVE` -- The server is in charge of the variable. Client changes will be overwritten when the server next changes it.
- `DOM_CLIENT_AUTHORITATIVE` -- The client(s) are in charge of the variable. By default, the client that created the object is the only one authorized to change client authoritative members. You can change the owner with `SetClientOwnerID`.

Example with two synchronized members:

```cpp
#include "DistributedNetworkObjectHeader.h"

class Tank : public DistributedNetworkObject
{
    void Update(void) { UpdateDistributedObject("Tank"); }
public:
    float turretAngle;
    Vector position;

    REGISTER_2_DISTRIBUTED_OBJECT_MEMBERS(DistributedNetworkObject,
        DOM_INTERPOLATE_COMPRESSED, DOM_CLIENT_AUTHORITATIVE, float, turretAngle,
        DOM_COPY_UNCOMPRESSED, DOM_SERVER_AUTHORITATIVE, Vector, position)
};

REGISTER_DISTRIBUTED_CLASS(Tank);
```

### The SynchronizeMemory function

Synchronizing memory at runtime uses the `SynchronizeMemory` function:

```cpp
class Tank : public DistributedNetworkObject
{
    Tank() {
        SynchronizeMemory(0, &turretAngle, sizeof(turretAngle), false);
        SynchronizeMemory(1, &position, sizeof(position), true);
    }

    void Update(void) { UpdateDistributedObject("Tank"); }
public:
    float turretAngle;
    Vector position;
};

REGISTER_DISTRIBUTED_CLASS(Tank);
```

The first parameter is a unique `unsigned char` to identify the variable. The second parameter is the memory address. The third parameter is the block size. The last parameter is `true` for server authority, `false` for client authority.

See `Samples\CodeSamples\DistributedNetworkObject\DistributedNetworkObjectSample.cpp` for an implementation example.

## User functions

| Function | Description |
|---|---|
| `UpdateDistributedObject(char *classID, bool isClassIDEncoded=false)` | Call every update cycle for every distributed object. `classID` should match the parameter to `REGISTER_DISTRIBUTED_CLASS`. |
| `SetMaximumUpdateFrequency(unsigned long frequency)` | Sets the maximum frequency for memory synchronization packets. Lower values increase granularity but require more bandwidth. |
| `DestroyObjectOnNetwork()` | Broadcasts a request to destroy an object on the network. |
| `AllowSpectatorUpdate(PlayerID sender)` | Server only. Return `true` to allow a non-owner client to update fields. Default returns `false`. |
| `SynchronizeMemory(...)` | Tags memory to be synchronized. |
| `DesynchronizeMemory(unsigned char memoryBlockIndex)` | Untags formerly synchronized memory. |
| `WriteCreationData(BitStream *initialData)` | Write data needed to create/initialize the object on remote systems. |
| `ReadCreationData(BitStream *initialData)` | Read data written from `WriteCreationData` on remote systems. |
| `OnNetworkUpdate(PlayerID sender)` | Called when distributed data changes. Override to validate data on the server. |
| `OnDistributedObjectCreation(PlayerID senderID)` | Called when the object is created by the network. Return `true` to accept, `false` to reject. You must call the base class version. |
| `OnDistributedObjectDestruction(PlayerID senderID)` | Called when the object is destroyed by the network. Default deletes itself. |
| `OnDistributedObjectRejection()` | Called when the server rejects an object the client created. Default destroys the object. |

## See Also

- [Bitstreams](/basics/bitstreams)
- [Timestamping](/basics/timestamping)

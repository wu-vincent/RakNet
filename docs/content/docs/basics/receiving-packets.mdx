---
title: "Receiving Packets"
description: "How to receive and process incoming network packets by identifying their type and decoding data from structs or bitstreams."
---

## Receiving a packet

When a packet arrives on the network (i.e., `Receive` returns non-zero), there are three steps to handle it:

1. Determine the packet type. This is returned by the following code

```cpp
unsigned char GetPacketIdentifier(Packet *p) {
    if ((unsigned char)p->data[0] == ID_TIMESTAMP) {
        return (unsigned char)p->data[sizeof(unsigned char) + sizeof(unsigned long)];
    } else {
        return (unsigned char)p->data[0];
    }
}
```

2. Process the data

## Receiving a structure

If you originally sent a structure, you can cast it back as follows:

```cpp
if (GetPacketIdentifier(packet) == /* User assigned packet identifier here */) {
    DoMyPacketHandler(packet);
}

// Put this anywhere you want.  Inside the state class that handles the game is
// a good place
void DoMyPacketHandler(Packet *packet) {
    // Cast the data to the appropriate type of struct
    MyStruct *s = (MyStruct *)packet->data;
    assert(p->length == sizeof(MyStruct)); // This is a good idea if you're transmitting structs.
    if (p->length != sizeof(MyStruct)) {
        return;
    }

    // Perform the functionality for this type of packet, with your struct,
    // MyStruct *s
}
```

<Callout type="info">
**Usability notes:**

-   The packet data is cast to a pointer to the appropriate struct type to avoid copy overhead. However, modifying the struct data also modifies the packet. Take care when relaying messages as a server, as this can cause unintended bugs.
-   The assert, while not necessary, is useful for catching hard-to-find bugs from assigning the wrong identifier or wrong size when sending the packet.
-   The if statement guards against packets of invalid size or type that could crash the client or server.
</Callout>

## Receiving a bitstream

If you originally sent a bitstream, create a bitstream to unparse the data in the same order it was written. Construct a bitstream using the packet data and length. Use the `Read` functions where you formerly used `Write`, `ReadCompressed` where you formerly used `WriteCompressed`, and follow the same logical branching if any data was written conditionally. The following example reads the data for the mine created in [Creating Packets](/basics/creating-packets).

```cpp
void DoMyPacketHandler(Packet *packet) {
    Bitstream myBitStream(packet->data, packet->length,
                          false); // The false is for efficiency so we don't
                                  // make a copy of the passed data
    myBitStream.Read(useTimeStamp);
    myBitStream.Read(timeStamp);
    myBitStream.Read(typeId);
    bool isAtZero;
    myBitStream.Read(isAtZero);
    if (isAtZero == false) {
        x = 0.0f;
        y = 0.0f;
        z = 0.0f;
    } else {
        myBitStream.Read(x);
        myBitStream.Read(y);
        myBitStream.Read(z);
    }

    myBitStream.Read(networkID);     // In the struct this is NetworkID networkId
    myBitStream.Read(systemAddress); // In the struct this is SystemAddress systemAddress
}
```

3. Deallocate the packet by passing it to `DeallocatePacket(Packet *packet)` on the same `RakPeerInterface` instance that returned it.

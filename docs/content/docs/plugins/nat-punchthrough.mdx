---
title: "NAT Punch-through"
description: "Enable peer-to-peer connectivity through NAT routers using the NatPunchthrough plugin with a facilitator server and optional UDP proxy fallback."
---

### What is NAT?

NAT is short for network address translation. It is used by routers to map addresses behind the router to a single destination address, using different ports. For example, if you have two computers behind a router, but only one ISP, then both computers will use the same IP address, but with different source ports than what the application actually assigned. The router keeps a lookup table of what mappings it provides, so when a remote computer replies it is routed to the correct local computer behind the NAT.

The problem with NAT is that remote computers cannot initiate sends to local computers because no mapping yet exists. Therefore, if two computers both behind NAT try to connect, neither will be able to do so. This is a problem with voice communication, peer to peer games, or games where your users host and the host is behind a NAT. In the old days your users would have to go to their router configuration screen and setup a mapping. However, in modern applications users are not usually required to do this, thanks to NatPunchthrough.

### NAT Punchthrough Overview

The NatPunchthroughClient.cpp plugin requires a user hosted server, not behind NAT, running NatPunchthroughServer.cpp that both clients can connect to. The server will find the external IP address of each client, and tell both clients to connect to that address at the same time. If that fails, each client will attempt to estimate the ports used by the other. If that fails, the process repeats once again, in case later port estimation opened a prior port. If that also fails, the plugin returns ID_NAT_PUNCHTHROUGH_FAILED.

<Callout type="info">
- If you publish through Steam, you can also use [SteamLobby](/plugins/steam-lobby), which uses servers hosted by Valve, in which case NATPunchthrough is not necessary.
- NAT Punchthrough is not necessary if exclusively using [IPv6](/basics/ipv6-support).
- If your game is client/server only, you may simply enforce that servers must support UPNP. See _DependentExtensions\\miniupnpc-1.6.20120410_. Most routers support this these days, and assuming UPNP passes, anyone can connect to you.
</Callout>

### NAT Punchthrough Algorithm

1.  Peer P1 wants to connect to peer P2, both of whom are connected to a third non-NAT system, F.
2.  Peer P1 calls OpenNAT() with the RakNetGUID (unique identifier) of P2 to F.
3.  F returns failure if P2 is not connected, or already attempting punchthrough to P1.
4.  F remembers busy state of P1 and P2. If either P1 or P2 is busy, the request is pushed to a queue. Otherwise F requests most recently used external port from P1 and P2. P1 and P2 are flagged as busy.
5.  If either P1 or P2 do not respond punchthrough fails with ID_NAT_TARGET_UNRESPONSIVE and the busy flag is unset. Otherwise, F sends timestamped connection message to P1 and P2 simultaneously.
6.  P1 and P2 act identically at this point. First, they send multiple UDP datagrams to each other's internal LAN addresses. They then try each other's external IP/port as seen by F. Ports are attempted sequentially, up to MAX_PREDICTIVE_PORT_RANGE.
7.  If at any point a datagram arrives from the remote peer, we enter state PUNCHING_FIXED_PORT. Datagrams are only sent to that IP/port combination the remainder of the algorithm. If our reply arrives on the remote system, the NAT is considered bidirectional and ID_NAT_PUNCHTHROUGH_SUCCEEDED is returned to the user.
8.  When NAT is open, or if we exhaust all ports, P1 and P2 send to F that they are ready for a new punchthrough attempt.

Algorithm effectiveness depends on the NAT types involved. It will work with whichever NAT is the most permissive.

**Full cone NAT**: Accepts any datagrams to a port that has been previously used. Will accept the first datagram from the remote peer.

**Address-Restricted cone NAT**: Accepts datagrams to a port as long as the datagram source IP address is a system we have already sent to. Will accept the first datagram if both systems send simultaneously. Otherwise, will accept the first datagram after we have sent one datagram.

**Port-Restricted cone NAT**: Same as address-restricted cone NAT, but we had to send to both the correct remote IP address and correct remote port. The same source address and port to a different destination uses the same mapping.

**Symmetric NAT**: A different port is chosen for every remote destination. The same source address and port to a different destination uses a different mapping. Since the port will be different, the first external punchthrough attempt will fail. For this to work it requires port-prediction (`MAX_PREDICTIVE_PORT_RANGE>1`) and that the router chooses ports sequentially.

**Success Graph**

| Router Type | Full Cone NAT | Address-Restricted Cone NAT | Port-Restricted Cone NAT | Symmetric NAT |
|---|---|---|---|---|
| Full Cone NAT | YES | YES | YES | YES |
| Address-Restricted Cone NAT | YES | YES | YES | YES |
| Port-Restricted Cone NAT | YES | YES | YES | NO* |
| Symmetric NAT | YES | YES | NO* | NO* |

*NO may still connect if port estimation works, but can't be relied upon.*

### Client Implementation

<Steps>
<Step>

### Create the plugin

Create an instance of the plugin: `NatPunchthroughClient natPunchthroughClient;`

</Step>

<Step>

### Attach to RakPeerInterface

Attach the plugin to an instance of RakPeerInterface: `rakPeer->AttachPlugin(&natPunchthroughClient);`

</Step>

<Step>

### Connect to the facilitator server

Connect to the server, and wait for ID_CONNECTION_REQUEST_ACCEPTED. You will need to host your own facilitator server.

</Step>

<Step>

### Call OpenNAT

Call OpenNAT with the RakNetGUID (globally unique identifier) of the remote system that you want to connect to. In order to get the RakNetGUID, you would either have to transmit it with your own code on the server, upload it to the PHPDirectoryServer, or use a plugin that stores it, such as LightweightDatabase: `natPunchthroughClient.OpenNAT(remoteGuid, serverSystemAddress);`. In order to read your own RakNetGUID, use `RakPeerInterface::GetGuidFromSystemAddress(UNASSIGNED_SYSTEM_ADDRESS);`

</Step>

<Step>

### Wait for the result

Wait a while. It may take over 10 seconds to try every possible port twice, although it often works within a couple of seconds. If you want to get text messages on what is happening, you can use `NatPunchthroughClient::SetDebugInterface()`.

</Step>

<Step>

### Handle the outcome

ID_NAT_PUNCHTHROUGH_SUCCEEDED means the punchthrough succeeded, and you should be able to connect or send other messages to the remote system. Packet::SystemAddress is the address of the system you can now connect to. Any other ID_NAT_* means the punchthrough failed. See MessageIdentifiers.h for the list of codes and comments on each.

</Step>
</Steps>

### Server Implementation

<Callout type="warn">
The facilitator server must not be behind NAT. It needs a static IP address (or Dynamic DNS), no firewall on the appropriate ports, and enough bandwidth to handle all connections.
</Callout>

<Steps>
<Step>

### Host a server

Host a server somewhere, not using NAT / e.g. behind a firewall.

</Step>

<Step>

### Create the plugin

Create an instance of the plugin: `NatPunchthroughServer natPunchthroughServer;`

</Step>

<Step>

### Attach the plugin

Attach the plugin: `rakPeer->AttachPlugin(&natPunchthroughServer);`

</Step>

<Step>

### Start RakPeer

Don't forget to call `RakPeerInterface::Startup()` and `RakPeerInterface::SetMaximumIncomingConnections(MAX_CONNECTIONS);`

</Step>
</Steps>

### Using the NatPunchthrough class

See the sample _\\Samples\\NATCompleteClient_ and _\\Samples\\NATCompleteServer_.

## UDP Proxy

With some poor quality or homemade routers, it is possible that NAT punchthrough will not work. For example, a router that picks a new random port for each outgoing connection, and will only allow incoming connections to this port, will never work. This happens about 5% of the time. To handle this case, RakNet provides the UDPProxy system. Essentially, it uses a server that you run to route messages between the source and destination client transparently. This even works to route datagrams from games not using RakNet (though you need RakNet to setup the forwarding). The combination of NATPunchthrough and UDPProxy should enable any system to connect to any other system with a 100% success rate, provided you are willing to host enough proxy servers to forward all the traffic.

The UDP Proxy system uses 3 main classes:

-   **UDPProxyClient**: Makes requests of UDPProxyCoordinator to setup forwarding. This is the class the client runs.
-   **UDPProxyCoordinator**: Runs on the server that will get all requests from UDPProxyClient. Also, gets all logins from UDPProxyServer.
-   **UDPProxyServer**: Actually does the UDP datagram forwarding, via a composite instance of UDPForwarder.cpp.


### Client Implementation

<Steps>
<Step>

### Create the plugin

Create an instance of the plugin: `UDPProxyClient udpProxyClient;`

</Step>

<Step>

### Create a result handler

Derive a class from `RakNet::UDPProxyClientResultHandler` to get event notifications for the system.

</Step>

<Step>

### Attach the plugin

Attach the plugin to an instance of RakPeerInterface: `rakPeer->AttachPlugin(&udpProxyClient);`

</Step>

<Step>

### Set the result handler

Call UDPProxyClient::SetResultHandler() on the class created in step 2.

</Step>

<Step>

### Try NAT punchthrough first

Try NATPunchthrough first. If you get ID_NAT_PUNCHTHROUGH_FAILED for the system that initiated NATPunchthrough, go to step 6. Both systems will return ID_NAT_PUNCHTHROUGH_FAILED, however, only one system needs to start the proxy system.

</Step>

<Step>

### Request forwarding

Call UDPProxyClient::RequestForwarding with the address of the coordinator, the address you want to forward from (UNASSIGNED_SYSTEM_ADDRESS for your own), the address you want to forward to, and how long to keep the forwarding active on no data. For example:

```cpp
SystemAddress coordinatorAddress;
coordinatorAddress.SetBinaryAddress("8.17.250.34");
coordinatorAddress.port=60481;
udpProxyClient.RequestForwarding(coordinatorAddress, UNASSIGNED_SYSTEM_ADDRESS, p->systemAddress, 7000);
```

</Step>

<Step>

### Handle the result

Assuming you are connected to the coordinator, and the coordinator is running the plugin, your event handler class created in step 2 should get a callback within a second or two. `UDPProxyClientResultHandler::OnForwardingSuccess` will be returned if a UDPProxyServer has been assigned to forward datagrams from the source system specified in step 6, to the target system specified in step 6. For example, to connect to the remote system use: `rakPeer->Connect(proxyIPAddress, proxyPort, 0, 0);`

</Step>
</Steps>

If more than one server is available, and both source and target relay systems are running RakNet, then source and target will automatically ping all available servers. The servers will be attempted in order of lowest ping sum to highest. This is based on the assumption that the lowest ping sum gives you the server that has the shortest path between the two systems, and therefore the least lag.

### Coordinator Implementation

<Steps>
<Step>

### Create the plugin

Create an instance of the plugin: `UDPProxyCoordinator udpProxyCoordinator;`

</Step>

<Step>

### Attach the plugin

Attach the plugin to an instance of RakPeerInterface: `rakPeer->AttachPlugin(&udpProxyCoordinator);`

</Step>

<Step>

### Set the password

Set the password on the coordinator for the servers to use: `udpProxyCoordinator.SetRemoteLoginPassword(COORDINATOR_PASSWORD);`

</Step>

<Step>

### Start RakPeer

Don't forget to call `RakPeerInterface::Startup()` and `RakPeerInterface::SetMaximumIncomingConnections(MAX_CONNECTIONS);`

</Step>
</Steps>

### Server Implementation

<Steps>
<Step>

### Create the plugin

Create an instance of the plugin: `UDPProxyServer udpProxyServer;`

</Step>

<Step>

### Attach the plugin

Attach the plugin to an instance of RakPeerInterface: `rakPeer->AttachPlugin(&udpProxyServer);`

</Step>

<Step>

### Connect to the coordinator

Connect to the coordinator.

</Step>

<Step>

### Log in to the coordinator

Login to the coordinator. This can be done at runtime, so you can dynamically add more forwarding servers as your game is more popular.
`udpProxyServer.LoginToCoordinator(COORDINATOR_PASSWORD, coordinatorSystemAddress);`
If the coordinator plugin is on the same system as the server plugin, use:
`udpProxyServer.LoginToCoordinator(COORDINATOR_PASSWORD, rakPeer->GetInternalID(UNASSIGNED_SYSTEM_ADDRESS));`

</Step>

<Step>

### Set up result handler (optional)

If you want to get callbacks as events occur (especially login failure) derive from `RakNet::UDPProxyServerResultHandler` and register your derived class with `UDPProxyServer::SetResultHandler()`.

</Step>
</Steps>

**State diagram with UDP Proxy**

[![](/images/natpunchpanel1small.jpg)](/images/natpunchpanel1.jpg)
[![](/images/natpunchpanel2small.jpg)](/images/natpunchpanel2.jpg)
[![](/images/natpunchpanel3small.jpg)](/images/natpunchpanel3.jpg)
[![](/images/natpunchpanel4small.jpg)](/images/natpunchpanel4.jpg)
[![](/images/natpunchpanel5small.jpg)](/images/natpunchpanel5.jpg)
[![](/images/natpunchpanel6small.jpg)](/images/natpunchpanel6.jpg)
[![](/images/natpunchpanel7small.jpg)](/images/natpunchpanel7.jpg)

## Server hosting

### Server requirements

1.  No network address translation.
2.  No firewall, or firewall opened on the appropriate ports.
3.  Static IP address. Dynamic DNS is one way to get around this requirement.
4.  Compile with __GET_TIME_64BIT if you want to run the server longer than a month without rebooting.
5.  Enough bandwidth to handle all connections.

### NAT Punchthrough Panels

![NAT Punchthrough Panel](/images/natpunchpanel1.jpg)

![NAT Punchthrough Panel](/images/natpunchpanel2.jpg)

![NAT Punchthrough Panel](/images/natpunchpanel3.jpg)

![NAT Punchthrough Panel](/images/natpunchpanel4.jpg)

![NAT Punchthrough Panel](/images/natpunchpanel5.jpg)

![NAT Punchthrough Panel](/images/natpunchpanel6.jpg)

![NAT Punchthrough Panel](/images/natpunchpanel7.jpg)

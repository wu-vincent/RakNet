---
title: "Debugging Disconnections"
description: "Step-by-step guide for tracing and debugging disconnections or missing packets in RakNet's datagram processing pipeline."
---

## Tracing and debugging received datagrams

If systems are getting disconnected or receiving no data, and standard debugging has not identified the cause, the following overview of how RakNet handles incoming messages can help isolate the problem.

<Steps>

<Step>

### SocketLayer::RecvFromBlocking() in SocketLayer.cpp

`RecvFromBlocking()` is called from a thread `RecvFromLoop` created in `RakPeer.cpp`. Every arriving datagram passes through this function, making it the first place to set a breakpoint when no data is received.

```cpp
*bytesReadOut = recvfrom(s, dataOutModified, dataOutSize, flag, sockAddrPtr, socketlenPtr);
```

This function should return with `bytesReadOut` greater than 0. If a breakpoint placed after this call is never hit, no datagrams arrived. At the bottom of the function, the following code reads the sender's address and port.

```cpp
systemAddressOut->port = ntohs(sa.sin_port);
systemAddressOut->binaryAddress = sa.sin_addr.s_addr;
```

The datagram ends up in the `rakPeer->bufferedPackets` queue. The function `SetEvent()` is called on the `rakPeer->quitAndDataEvents` `SignaledEvent` class, which tells the `UpdateNetworkLoop()` thread to stop waiting and process the message.

<Callout type="info">
If this breakpoint is never hit, the problem is in the network layer itself.
</Callout>

</Step>

<Step>

### RakPeer::RunUpdateCycle() in RakPeer.cpp

`RunUpdateCycle()` is an update function that `UpdateNetworkLoop` calls many times per second. It is triggered by either a timer or by the `rakPeer->quitAndDataEvents` `SignaledEvent` class. For debugging message flows, set a breakpoint near the top of the function here:

```cpp
if (socketListIndex != socketList.Size()) {
    ProcessNetworkPacket(recvFromStruct->systemAddress, recvFromStruct->data,
                         recvFromStruct->bytesRead, this, socketList[socketListIndex],
                         recvFromStruct->timeRead);
}
```

When a datagram is put in the `rakPeer->bufferedPackets` queue from step 1, it is processed here.

<Callout type="info">
If this breakpoint is not hit, either the thread is not running (unlikely), there is a bug in the `SignaledEvent` class, or the thread has locked up somewhere.
</Callout>

</Step>

<Step>

### ProcessNetworkPacket(...) in RakPeer.cpp

`ProcessNetworkPacket` is called for each incoming datagram. At the top of the function, `ProcessOfflineNetworkPacket()` is called. It checks whether the sender is banned and whether the message is prefixed with `OFFLINE_MESSAGE_DATA_ID`. If the sender is banned, the function returns and no further processing occurs. If the message is prefixed with `OFFLINE_MESSAGE_DATA_ID`, it is typically a handshaking message, and `ProcessNetworkPacket()` does not process further. For already-connected systems, `ProcessOfflineNetworkPacket()` returns `false`. When debugging message loss for a known-connected system, step over `ProcessOfflineNetworkPacket` and only trace into it if it returns `true`.

The next operation in `ProcessNetworkPacket()` is looking up the remote system structure from the `systemAddress` (IP address) by calling `rakPeer->GetRemoteSystemFromSystemAddress( systemAddress, true, true )`. A `remoteSystem` structure should be returned. If not, the sender's IP address is unknown and the message is not tagged as offline, so the datagram is ignored.

`ProcessNetworkPacket()` should then proceed to

```cpp
remoteSystem->reliabilityLayer.HandleSocketReceiveFromConnectedPlayer(
    data,
    length,
    systemAddress,
    rakPeer->messageHandlerList,
    remoteSystem->MTUSize,
    rakNetSocket->s,
    &rnr,
    rakNetSocket->remotePortRakNetWasStartedOn_PS3,
    timeRead);
```

<Callout type="info">
If `HandleSocketReceiveFromConnectedPlayer()` is not called, possible causes are: the sender is not connected, the sender is banned, the sender was recently disconnected, there is a bug in `GetRemoteSystemFromSystemAddress()`, or the connected datagram encoding coincidentally matched `OFFLINE_MESSAGE_DATA_ID` (which should not happen except due to bugs).
</Callout>

</Step>

<Step>

### ReliabilityLayer::HandleSocketReceiveFromConnectedPlayer(...)

This function processes a datagram from a connected player. Each datagram roughly follows the `DatagramHeaderFormat` structure at the top of the file. A datagram is either an acknowledgement (ACK) of previously sent datagrams, a negative acknowledgement (NAK) of datagrams that did not arrive, or one or more user-generated messages from `RakPeer::Send()`.

This function is large, but you generally do not need to deal with ACKs or NAKs. Skip to the part that reads:

```cpp
InternalPacket *internalPacket = CreateInternalPacketFromBitStream(&socketData, timeRead);
```

`ReliabilityLayer::CreateInternalPacketFromBitStream(...)` reads the header for each user message. The header contains the message length, whether the message was fragmented, and whether it needs ordering. If the message format is invalid, the function returns 0. Otherwise, an `InternalPacket` structure is allocated and returned with the user data filled in.

If the very first call to the function fails, that is a bug. However, a datagram can contain more than one message, so the function is called in a loop until failure.

```cpp
while (internalPacket) {
    ...
        // Parse the bitstream to create an internal packet
        internalPacket = CreateInternalPacketFromBitStream(&socketData, timeRead);
}
```

Immediately inside that loop is this block of code:

```cpp
for (unsigned int messageHandlerIndex = 0; messageHandlerIndex < messageHandlerList.Size();
     messageHandlerIndex++) {
#if CC_TIME_TYPE_BYTES == 4
    messageHandlerList[messageHandlerIndex]->OnInternalPacket(internalPacket, receivePacketCount,
                                                              systemAddress, timeRead, false);
#else
    messageHandlerList[messageHandlerIndex]->OnInternalPacket(
        internalPacket, receivePacketCount, systemAddress,
        (RakNet::TimeMS)(timeRead / (CCTimeType)1000), false);
#endif
}
```

`OnInternalPacket()` is used by the `PacketLogger` plugin. If messages appear to be sent but are not listed by `PacketLogger`, execution did not reach this point.

The next block of code checks if this is a duplicate message.

```cpp
holeCount =
    (DatagramSequenceNumberType)(internalPacket->reliableMessageNumber - receivedPacketsBaseIndex);
const DatagramSequenceNumberType typeRange = (DatagramSequenceNumberType)(const uint32_t)-1;
```

This is the start of a major block of code. `receivedPacketsBaseIndex` increments by one for each message arriving from the remote system. If messages arrive in order, `holeCount` is 0. If a message skips one index, `holeCount` is 1. If a message is an immediate duplicate, `holeCount` is negative 1 and the message is ignored. `hasReceivedPacketQueue` is a boolean queue indicating whether a message was received for a given index. One potential failure point is this code:

```cpp
if (holeCount > (DatagramSequenceNumberType)1000000) {
    RakAssert("Hole count too high. See ReliabilityLayer.h" && 0);
    ...
}
```

To avoid memory attacks, the queue size is limited to that number. In practice a message should never be out of order by that much, even on a LAN.

If the message was split by the sender, `ReliabilityLayer::InsertIntoSplitPacketList(...)` is called. When all parts of a message have arrived, `ReliabilityLayer::BuildPacketFromSplitPacketList()` returns the reassembled message.

`HandleSocketReceiveFromConnectedPlayer` may return zero or more messages to the user. They are pushed to the `outputQueue`, for example:

```cpp
outputQueue.Push(internalPacket, _FILE_AND_LINE_);
```

<Callout type="info">
The most likely failure point here should you not get data is a bug with the packet format in `CreateInternalPacketFromBitStream()`.
</Callout>

</Step>

<Step>

### ReliabilityLayer::Receive(unsigned char \*\*data)

This function returns messages pushed to the `outputQueue`. It is called from `RakPeer::RunUpdateCycle()` at a regular interval, once for each connected system.

</Step>

<Step>

### RakPeer::RunUpdateCycle(RakNet::TimeUS timeNS, RakNet::Time timeMS)

```cpp
// Does the reliability layer have any packets waiting for us?
// To be thread safe, this has to be called in the same thread as
// HandleSocketReceiveFromConnectedPlayer
bitSize = remoteSystem->reliabilityLayer.Receive(&data);
```

As described in step 5, this code runs at a regular interval, once per connected system. If `bitSize` is greater than 0, a message from a connected system is available. This is typically a user message, though `RakPeer` also checks for messages the user should not send (such as `ID_CONNECTION_REQUEST`), because part of the handshaking process is done reliably.

Assuming this is a user message, it is pushed to a queue here:

```cpp
if (data[0] >= (MessageID)ID_TIMESTAMP && remoteSystem->isActive) {
    packet = AllocPacket(byteSize, data, _FILE_AND_LINE_);
    packet->bitSize = bitSize;
    packet->systemAddress = systemAddress;
    packet->systemAddress.systemIndex = (SystemIndex)remoteSystemIndex;
    packet->guid = remoteSystem->guid;
    packet->guid.systemIndex = packet->systemAddress.systemIndex;
    AddPacketToProducer(packet);
}
```

This adds the message to the `packetReturnQueue` queue found in `RakPeer`.

</Step>

<Step>

### Packet\* RakPeer::Receive(void)

`Receive()` is called by application code. `Update()` runs for all plugins, then `packetReturnQueue` is checked for messages to return to the caller.

</Step>

</Steps>

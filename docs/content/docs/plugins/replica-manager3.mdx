---
title: "Replica Manager 3"
description: "Automatically create, destroy, and serialize networked game objects across all connected systems using the ReplicaManager3 plugin."
---

## Replica Manager 3 Implementation Overview

Any game that has objects created and destroyed while the game is in progress -- almost all non-trivial games -- faces a minimum of three problems:

-   How to broadcast existing game objects to new players
-   How to broadcast new game objects to existing players
-   How to broadcast deleted game objects to existing players

Additional potential problems, depending on complexity and optimization:

-   How to create and destroy objects dynamically as the player moves around the world
-   How to allow the client to create objects locally when this is necessary right away for programming or graphical reasons (such as shooting a bullet).
-   How to update objects as they change over time

The solution to most of these problems is straightforward, yet still requires significant work and debugging, with several dozen lines of code per object.

`ReplicaManager3` is designed to be a generic, overridable plugin that handles as many of these details as possible automatically. `ReplicaManager3` automatically creates and destroys objects, downloads the world to new players, manages players, and automatically serializes as needed. It also includes the advanced ability to automatically relay messages, and to automatically serialize your objects when the serialized member data changes.

**Order of operations:**

Objects are remotely created in the order they are registered using `ReplicaManager3::Reference()`. All objects created or destroyed in a tick are created or destroyed in the same packet, meaning all calls to construct or destroy objects are triggered by the same `RakPeerInterface::Receive()` call.

`Serialize()` happens after construction. Therefore, all objects are created and have `DeserializeConstruction()` called before any `Serialize()` call happens for any of the objects created that update tick. Unlike construction, `Serialize()` calls may be spread out over multiple calls to `RakPeerInterface::Receive()` depending on bandwidth availability. Send all data necessary for the object to be properly set up in the initial `SerializeConstruction()` call, since receiving `Deserialize()` on the same tick is not guaranteed.

The first time objects are sent to a remote system, `Connection_RM3::DeserializeOnDownloadComplete()` fires once all objects have been constructed and `Deserialized()`.

<Callout type="info">
**Dependency resolution:** If one object refers to another (for example, a gun has a pointer to its owner), the dependent objects must be created first. In the case of a gun with a pointer to its owner, create the owner first. The gun serializes the `NetworkID` of the owner and looks up the owner in its `DeserializeConstruction` call. Achieve this by registering the objects in that order using `ReplicaManager3::Reference()`.

Sometimes you have dependency chains that cannot be resolved through reordering. For example, a player has an inventory list, and each item in the inventory has a pointer to its owner. Or you may have a circular chain, where A depends on B, B depends on C, and C depends on A. Or it may not be feasible to reorder the objects. For these cases, you can resolve dependencies in the `Replica3::PostDeserializeConstruction()` callback. `PostDeserializeConstruction()` is called after `DeserializeConstruction()` completes for all objects in a given update tick, so all objects that are going to be created will have been created by then.
</Callout>

<Callout type="info">
**Static Objects:** Sometimes you have an object that already exists in the world and is known to all systems. For example, a door on level load. In those situations you usually do not want the server to transmit the object creation message, since it would result in the same door twice. Yet you still want to reference and serialize the object, such as the door opening and closing, or the remaining health for the door.

To handle static objects:

1. Derive your object from `Replica3`
2. BEFORE calling `replicaManager3->Reference()` on the object, call `replica3Object->SetNetworkIDManager(replicaManager3->GetNetworkIDManager());`
3. BEFORE calling `replicaManager3->Reference()` on the object, call `replica3Object->SetNetworkID(unique64BitIDLoadedWithLevel);`
4. Return `RM3CS_ALREADY_EXISTS_REMOTELY` from `QueryConstruction()` from the host/server. Otherwise return `RM3CS_ALREADY_EXISTS_REMOTELY_DO_NOT_CONSTRUCT`. Alternatively, use `QueryConstruction_PeerToPeer()` with `R3P2PM_STATIC_OBJECT_CURRENTLY_AUTHORITATIVE` or `R3P2PM_STATIC_OBJECT_NOT_CURRENTLY_AUTHORITATIVE`.
5. `WriteAllocationID()`, `SerializeConstruction()`, `DeserializeConstruction()` are not used for static objects, and can have empty implementations.
6. If the object should also never be destroyed over the network, implement `QueryActionOnPopConnection()` to return `RM3AOPC_DO_NOTHING`. `SerializeDestruction()`, `DeserializeDestruction()`, `DeallocReplica()` can have empty implementations.
7. Return whatever you want from `QueryRemoteConstruction()`, as it will not be called.
8. Implement `QuerySerialization()` to return `RM3QSR_CALL_SERIALIZE` from the system that serializes the object, typically the peer to peer host or the server. If a system is not currently but can later become a host, such as for peer to peer with host migration, return `RM3QSR_DO_NOT_CALL_SERIALIZE`. Otherwise return `RM3QSR_NEVER_CALL_SERIALIZE`. Alternatively, use `QuerySerialization_PeerToPeer()` with `R3P2PM_STATIC_OBJECT_CURRENTLY_AUTHORITATIVE` or `R3P2PM_STATIC_OBJECT_NOT_CURRENTLY_AUTHORITATIVE`.
9. Write to the `BitStream` in `SerializeConstructionExisting()` your one-time initialization data, and read it in `DeserializeConstructionExisting()`. This function is called if and only if `QueryConstruction` returns `RM3CS_ALREADY_EXISTS_REMOTELY`.
10. Write per-tick serialization data in `Serialize()`, and read it in `Deserialize()`.

`RM3CS_ALREADY_EXISTS_REMOTELY` causes `ReplicaManager3` to consider the door to exist on the other system, so when `Serialize()` is called, updates are still sent to that system. The `SerializeConstruction()` call and object creation are skipped.
</Callout>

## Combining with FullyConnectedMesh2

If you are using [FullyConnectedMesh2](/plugins/fully-connected-mesh2) for host determination and `ReplicaManager3` relies on a host, you must delay calling `AddParticipant()` until a host has been determined. Follow these steps:

<Steps>
<Step>

### Disable auto-manage connections

`replicaManager3->SetAutoManageConnections(false, [false or true, depends on your preference]);`

</Step>

<Step>

### Disable auto-participate (optional)

`fullyConnectedMesh2->SetAutoparticipateConnections(false);` (optional)

</Step>

<Step>

### Connect to all remote systems

Start connections to all remote systems.

</Step>

<Step>

### Handle new connections

On `ID_CONNECTION_REQUEST_ACCEPTED` or `ID_NEW_INCOMING_CONNECTION`, execute:

```cpp
// Add mid-game joins to ReplicaManager3 as long as we know who the host is
if (fullyConnectedMesh2->GetConnectedHost() != UNASSIGNED_RAKNET_GUID) {
    bool success = replicaManager3->PushConnection(
        replicaManager3->AllocConnection(packet->systemAddress, packet->guid));
    RakAssert(success);
}
```

</Step>

<Step>

### Handle first host determination

On `ID_FCM2_NEW_HOST` execute:

```cpp
BitStream bsIn(packet->data, packet->length, false);
bsIn.IgnoreBytes(sizeof(MessageID));
RakNetGUID oldHost;
bsIn.Read(oldHost);
if (oldHost == UNASSIGNED_RAKNET_GUID) {
    // First time calculated host. Add existing connections to ReplicaManager3
    AddFullyConnectedMesh2ParticipantsToReplicaManager3();
}
```

</Step>

<Step>

### Add participants helper function

```cpp
void AddFullyConnectedMesh2ParticipantsToReplicaManager3(void) {
    {
        DataStructures::List<RakNetGUID> participantList;
        fullyConnectedMesh2->GetParticipantList(participantList);
        for (unsigned int i = 0; i < participantList.Size(); i++) {
            Connection_RM3 *connection = replicaManager3->AllocConnection(
                rakPeer->GetSystemAddressFromGuid(participantList[i]), participantList[i]);
            if (replicaManager3->PushConnection(connection) == false) {
                replicaManager3->DeallocConnection(connection);
            }
        }
    };
```

</Step>
</Steps>

_Explanation:_

Step 1: The first parameter to `ReplicaManager3::SetAutoManageConnections()` is set to `false` to prevent `ReplicaManager3` from automatically calling `PushConnection()`, because systems should not participate in `ReplicaManager3` until a host has been determined. The second parameter is up to you.

Step 2: If every system that connects to you is another game instance, you can leave `SetAutoparticipateConnections()` as the default to `true`, and do not need to call `fullyConnectedMesh2->AddParticipant(packet->guid);` later either. The reason this is here is in case you want to connect to a profiling tool or other non-game program.

Step 3: `FullyConnectedMesh2` requires a fully connected mesh topology, so you need to connect to every other system in the game instance. This can be done with a `rakPeer->Connect()` call, or you can use systems such as [NAT punchthrough](/plugins/nat-punchthrough) depending on your needs. The code here works with both simultaneous startup from a lobby and mid-game joins. See the manual page on [connecting](/basics/connecting) for more information.

Step 4: Until a host has been determined, `fullyConnectedMesh2->GetConnectedHost()` returns `UNASSIGNED_RAKNET_GUID`. In that case, `replicaManager3->PushConnection()` is delayed until `ID_FCM2_NEW_HOST` is returned. However, if a host is already known (for example, the game is already in progress), then the remote system is added immediately.

Step 5: Once the host is known for the first time, all connected systems can be added to `ReplicaManager3`. `oldHost==UNASSIGNED_RAKNET_GUID` means there was no prior host.

Step 6: A function to uniquely add connections to `ReplicaManager3` given a list of remote `RakNetGUID`s.

## Integration with component-based systems

A component-based system is one where a game actor has a list of classes attached, each containing an attribute of the actor itself. For example, a player may have position, health, animation, and physics components.

1\. Instances of the same actor either have the same type, order, and number of components, or you must provide a way to identify components during serialization. To `Serialize()`, first `Serialize()` your actor, then `Serialize()` your components in order.

2\. Here is an example of `QuerySerialization()` in a peer-to-peer game where the host controls objects loaded with the level (static objects). Otherwise, the peer that created the object serializes it. A component can override this and allow the host to serialize the object regardless. For example, if a player puts a weapon on the ground, the weapon returns `RM3QSR_CALL_SERIALIZE` if the local system is the host, and `RM3QSR_DO_NOT_CALL_SERIALIZE` otherwise.

```cpp
if (IsAStaticObject()) {
    // Objects loaded with the level are serialized by the host
    if (fullyConnectedMesh2->IsHostSystem()) {
        return RM3QSR_CALL_SERIALIZE;
    } else {
        return RM3QSR_DO_NOT_CALL_SERIALIZE;
    }
} else {
    // Allow components opportunity to overwrite method of serialization
    for (int i = 0; i < components.Size(); i++) {
        RM3QuerySerializationResult res = components[i]->QuerySerialization(destinationconnection);
        if (res != RM3QSR_MAX) {
            return res;
        }
    }
    return QuerySerialization_PeerToPeer(destinationconnection);
}
```

3\. This variation, for `QueryConstruction()`, has components return `Replica3P2PMode` instead. Using the gun example, a gun may be controlled by the host when on the ground, or by another player when picked up. If `R3P2PM_MULTI_OWNER_CURRENTLY_AUTHORITATIVE` or `R3P2PM_MULTI_OWNER_NOT_CURRENTLY_AUTHORITATIVE` is returned by a component, then `QueryConstruction_PeerToPeer()` uses that value to return an appropriate value for `RM3ConstructionState`. Internally, `QueryConstruction_PeerToPeer()` returns `RM3CS_SEND_CONSTRUCTION` if the local system controls the object, `RM3CS_NEVER_CONSTRUCT` if the local system does not control the object and no other system ever can, and `RM3CS_ALREADY_EXISTS_REMOTELY` if another system controls the object but the owner can change.

```cpp
if (destinationConnection->HasLoadedLevel() == false) {
    return RM3CS_NO_ACTION;
}
if (IsAStaticObject()) {
    if (fullyConnectedMesh2->IsHostSystem()) {
        return RM3CS_ALREADY_EXISTS_REMOTELY;
    } else {
        return RM3CS_ALREADY_EXISTS_REMOTELY_DO_NOT_CONSTRUCT;
    }
} else {
    Replica3P2PMode p2pMode = R3P2PM_SINGLE_OWNER;
    for (int i = 0; i < components.Size(); i++) {
        p2pMode = components[i]->QueryP2PMode();
        if (p2pMode != R3P2PM_SINGLE_OWNER) {
            break;
        }
    }
    return QueryConstruction_PeerToPeer(destinationconnection, p2pMode);
}

virtual Replica3P2PMode BaseClassComponent::QueryP2PMode() {
    return R3P2PM_SINGLE_OWNER;
}

virtual Replica3P2PMode GunComponent::QueryP2PMode() {
    if (IsOnTheGround()) {
        if (fullyConnectedMesh2->IsHostSystem()) {
            return R3P2PM_MULTI_OWNER_CURRENTLY_AUTHORITATIVE;
        } else {
            return R3P2PM_MULTI_OWNER_NOT_CURRENTLY_AUTHORITATIVE;
        }
    } else if (WeOwnTheGun()) {
        return R3P2PM_MULTI_OWNER_CURRENTLY_AUTHORITATIVE;
    } else {
        return R3P2PM_MULTI_OWNER_NOT_CURRENTLY_AUTHORITATIVE;
    }
}
```

4\. To use composition instead of derivation, see `Replica3Composite` in `ReplicaManager3.h`. It is a templated class with only one member, `r3CompositeOwner`. All `Replica3` interfaces are queried on `r3CompositeOwner`.

**Methods of object serialization:**

<Tabs items={["Manual dirty flags", "Object-level change detection", "Per-variable delta"]}>
<Tab value="Manual dirty flags">
_Description_: When a variable changes, you set a flag indicating the change. The next `Serialize()` tick, you send all variables with dirty flags set.
_Pros_: Fast, memory efficient.
_Cons_: All replicated variables must change through accessors so the flags can be set. This is labor-intensive because you must program every dirty flag, and bugs are likely during the process.

```cpp
void SetHealth(float newHealth) {
    if (health == newHealth) {
        return;
    }
    health = newHealth;
    serializeHealth = true;
}
void SetScore(float newScore) {
    if (score == newScore) {
        return;
    }
    score = newScore;
    serializeScore = true;
}
virtual RM3SerializationResult Serialize(SerializeParameters *serializeParameters) {
    bool anyVariablesNeedToBeSent = false;
    if (serializeHealth == true) {
        serializeParameters->outputBitstream[0]->Write(true);
        serializeParameters->outputBitstream[0]->Write(health);
        anyVariablesNeedToBeSent = true;
    } else {
        serializeParameters->outputBitstream[0]->Write(false);
    }
    if (serializeScore == true) {
        serializeParameters->outputBitstream[0]->Write(true);
        serializeParameters->outputBitstream[0]->Write(score);
        anyVariablesNeedToBeSent = true;
    } else {
        serializeParameters->outputBitstream[0]->Write(false);
    }
    if (anyVariablesNeedToBeSent == false) {
        serializeParameters->outputBitstream[0]->Reset();
    }
    // Won't send anything if the bitStream is empty (was Reset()).
    // RM3SR_SERIALIZED_ALWAYS skips default memory compare
    return RM3SR_SERIALIZED_ALWAYS;
}
```

```cpp
virtual void Deserialize(RakNet::DeserializeParameters *deserializeParameters) {
    bool healthWasChanged, scoreWasChanged;
    deserializeParameters->serializationBitstream[0]->Read(healthWasChanged);
    if (healthWasChanged) {
        deserializeParameters->serializationBitstream[0]->Read(health);
    }
    deserializeParameters->serializationBitstream[0]->Read(scoreWasChanged);
    if (scoreWasChanged) {
        deserializeParameters->serializationBitstream[0]->Read(score);
    }
}
```
</Tab>
<Tab value="Object-level change detection">
_Description_: This is what `ReplicaManager3` comes with. If the object's state for a bitStream channel changes at all, the entire channel is resent.
_Pros:_ Easy to use for the programmer.
_Cons:_ Some variables will be sent unnecessarily, using more bandwidth than necessary. Moderate CPU and memory usage.

```cpp
void SetHealth(float newHealth) {
    health = newHealth;
}
virtual RM3SerializationResult Serialize(SerializeParameters *serializeParameters) {
    serializeParameters->outputBitstream[0]->Write(health);
    serializeParameters->outputBitstream[0]->Write(score);
    // Memory compares against last outputBitstream write. If changed, writes
    // everything on the changed channel(s), which can be wasteful in this case
    // if only health or score changed, and not both
    return RM3SR_BROADCAST_IDENTICALLY;
}
```

```cpp
virtual void Deserialize(RakNet::DeserializeParameters *deserializeParameters) {
    deserializeParameters->serializationBitstream[0]->Read(health);
    deserializeParameters->serializationBitstream[0]->Read(score);
}
```
</Tab>
<Tab value="Per-variable delta">
_Description_: Every variable is copied internally and compared to the last state.
_Pros:_ Maximum bandwidth savings.
_Cons:_ Heavy CPU and memory usage.

_Example (also see ReplicaManager3 sample project)_

```cpp
virtual RM3SerializationResult Serialize(SerializeParameters *serializeParameters) {
    VariableDeltaSerializer::SerializationContext serializationContext;
    // All variables to be sent using a different mode go on different channels
    serializeParameters->pro[0].reliability = RELIABLE_ORDERED;
    variableDeltaSerializer.BeginIdenticalSerialize(&serializationContext,
                                                    serializeParameters->whenLastSerialized == 0,
                                                    &serializeParameters->outputBitstream[0]);
    variableDeltaSerializer.SerializeVariable(&serializationContext, var3Reliable);
    variableDeltaSerializer.SerializeVariable(&serializationContext, var4Reliable);
    variableDeltaSerializer.EndSerialize(&serializationContext);
    return RM3SR_SERIALIZED_ALWAYS_IDENTICALLY;
}

virtual void Deserialize(RakNet::DeserializeParameters *deserializeParameters) {
    VariableDeltaSerializer::DeserializationContext deserializationContext;
    variableDeltaSerializer.BeginDeserialize(&deserializationContext,
                                             &deserializeParameters->serializationBitstream[0]);
    if (variableDeltaSerializer.DeserializeVariable(&deserializationContext, var3Reliable)) {
        printf("var3Reliable changed to %i\n", var3Reliable);
    }
    if (variableDeltaSerializer.DeserializeVariable(&deserializationContext, var4Reliable)) {
        printf("var4Reliable changed to %i\n", var4Reliable);
    }
    variableDeltaSerializer.EndDeserialize(&deserializationContext);
}
```
</Tab>
</Tabs>

**Quick start:**

<Steps>
<Step>

### Create Connection_RM3 subclass

Derive from `Connection_RM3` and implement `Connection_RM3::AllocReplica()`. This is a factory function: given an identifier for a class (such as name), return an instance of that class. It must be able to return any networked object in your game.

</Step>

<Step>

### Create ReplicaManager3 subclass

Derive from `ReplicaManager3` and implement `AllocConnection()` and `DeallocConnection()` to return the class you created in step 1.

</Step>

<Step>

### Create Replica3 subclass

Derive your networked game objects from `Replica3`. All pure virtuals must be implemented, though defaults are provided for `Replica3::QueryConstruction()` and `Replica3::QueryRemoteConstruction()` depending on your network architecture.

</Step>

<Step>

### Register objects

When a new game object is created on the local system, pass it to `ReplicaManager3::Reference()`.

</Step>

<Step>

### Destroy objects

When a game object is destroyed on the local system, and you want other systems to know about it, call `Replica3::BroadcastDestruction()`.

</Step>

<Step>

### Attach the plugin

Attach `ReplicaManager3` as a plugin.

</Step>
</Steps>

For a full list of functions with detailed documentation on each parameter, see `ReplicaManager3.h`.

The primary sample is located at _Samples/ReplicaManager3_.

## Differences between `ReplicaManager3` and `ReplicaManager2`

### `ReplicaManager3` is simpler and more transparent

1.  `Connection_RM2::Construct` is now two functions: `Connection_RM3::AllocReplica` and `Connection_RM3::DeserializeConstruction`. Previously, you were given raw data in `Connection_RM2::Construct` and expected to both create and deserialize construction yourself. Now, `AllocReplica` creates the object and `DeserializeConstruction` fills out the data for the object.
2.  Because of the change above, `NetworkID`, `creatingSystemGUID`, and `replicaManager` are already set as member variables before you get the `DeserializeConstruction` callback. This simplifies usage because the object is already ready to use.
3.  Objects created the same tick were previously sent in individual messages. This means it was possible for the two objects to arrive on different remote game ticks for recipients already connected. This is a problem if two objects depend on each other before either will work. Now, all objects created the same tick (defined by calls to `RakPeerInterface::Receive()`, which calls `PluginInterface2::Update()`) are sent in the same message.
4.  Previously, you called `ReplicaManager2::SetConnectionFactory` with a special connection factory class to create instances of `Connection_RM2`. Now, `ReplicaManager3` itself has pure virtual functions `AllocConnection()` and `DeallocConnection()`.
5.  Previously, object references were implicit. A call to `ReplicaManager2::SendConstruction`, `ReplicaManager2::SendSerialize`, or `ReplicaManager2::SendVisibility` registered the instance if it did not already exist. Now, references are explicit, with `ReplicaManager3::Reference` replacing all three of those `ReplicaManager2` calls. This was a source of confusion, where those Send functions (or the Broadcast equivalents) did not check the corresponding `Replica2::Query*` functions. The Construction and Serialization functions are now gone and happen solely through the automatic update tick.
6.  `ReplicaManager2` did not support different serializations per-connection. `ReplicaManager3` does, by returning `RM3SR_SERIALIZED_UNIQUELY` from `ReplicaManager3::Serialize`. It is still more efficient to return `RM3SR_SERIALIZED_IDENTICALLY` if serializations are the same for all connections.
7.  `ReplicaManager3` does not support the visibility commands, such as `ReplicaManager2::SendVisibility`, to keep the system simpler and more transparent. To support this, add a boolean visibility flag. Transmit it once in `Serialize`, using `RM3SR_SERIALIZED_UNIQUELY`. On the remote system, if the visibility flag is `false`, hide the object. On the sending system, if the visibility flag is `false`, return `RM3SR_DO_NOT_SERIALIZE` from `ReplicaManager3::Serialize`. You can check if the visibility flag for this replica / connection pair has changed by reading `SerializeParameters::lastSerializationSent`, which contains the last transmitted value of `SerializeParameters::outputBitstream`.
8.  `ReplicaManager3` does not support `Connection_RM2::SerializeDownloadStarted` to keep the system simpler and more transparent. You can check the equivalent in the function `ReplicaManager3::SerializeConstruction` with the value of `destinationConnection->IsInitialDownload()`. For more complex behavior, you can also send data before registering the remote system. Call `ReplicaManager3::SetAutoManageConnections` with the `autoCreate` parameter as `false`. Send your data. Then call `ReplicaManager3::PushConnection`.
9.  `QueryDestruction` no longer exists. `QueryConstruction` now has a return value that indicates destruction.
10.  `QueryIs*Authority` no longer exists. Return values from the existing functions in `ReplicaManager3` achieve the same results.

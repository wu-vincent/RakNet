---
title: "Programming Tips"
description: "Miscellaneous tips for RakNet development covering debugging, lag elimination, client-server authority, timestamping, and bandwidth optimization."
---

<Callout type="info">
This section assumes you have already read the [Detailed Implementation](/getting-started/detailed-implementation). Read that first, then return here.
</Callout>

For information on data transfer, see [Creating Packets](/basics/creating-packets), [Sending Packets](/basics/sending-packets), and [Receiving Packets](/basics/receiving-packets).

## Debugging aids: PacketLogger and related classes

Logging incoming and outgoing packets is valuable for debugging. If a network-related crash occurs, the log shows which packets may have caused it. Attach an instance of `PacketLogger` (or a derived class) to your peer, configure parameters as needed, and all network traffic is logged.

## Eliminating visible lag

Eliminating visible lag improves both appearance and playability. The two most common techniques follow.

**Interpolation.** Suppose a player is at position 0,0 and a packet arrives placing them at 100,100. Rather than snapping the player to the new position, gradually slide them over. A straightforward approach: "the player reaches the new position within 300 ms." If the player is far off, the movement is fast; if close, it is slow. In practice, use more sophisticated algorithms such as spline interpolation between points. The right approach depends on the game and context.

**Optimistic prediction with rollback.** Allow the visible effect of an action to occur immediately, then undo it if the server disagrees. Consider a first-person shooter where every hit is lethal. If all hits are processed through the server, the victim falls dead a few hundred milliseconds after the shot -- the game feels unresponsive. Instead, process the visual effect (the player falling dead) immediately on the client. If the server determines the shot missed, undo the death and have the victim stand back up. Because the client is usually correct, the game feels identical to single player. Under high-lag conditions the rollbacks become visible, but that is unavoidable.

## Client vs. server authority

When creating any packet that affects other players, answer this question:

"Who is the authority on this event, the client or the server?"

This generally falls under three categories:

**The client is the authority.** An example is chatting. If a client writes a chat message, the server can assume the assertion is correct and process it directly.

**The server is the authority.** An example is connecting to a game. If the server tells a client it is not connected, the client cannot assume otherwise and start a game. Massively Multiplayer Online RPGs use this extensively.

**Both the client and the server have partial authority.** An example is shooting in a well-written first-person shooter: if the shooter does not see a hit, there is no hit; if the target's client does not see a hit, there is also no hit.

<Callout type="info">
Allowing the client to be authoritative makes gameplay feel responsive and fair from that client's perspective. However, under high lag it can be unfair to other players. Allowing the server to be authoritative is fair for everyone but produces a sluggish experience when actions appear delayed. Consider each case carefully to balance responsiveness for the acting client against fairness for others.
</Callout>

## Using timestamping to show more accurate positions

Use kinematics for moving objects. Because packets take time to arrive on a remote system, do not pass raw position data alone -- include velocity and acceleration. Timestamp the packet. When it arrives, the receiver computes the difference between its local time and the timestamp to determine elapsed time, then applies the kinematic formula to find the object's current position.

Formula for position with a constant acceleration:

```text
x = x0 + v * t + .5 * t * t
```

`x` is the final position. `x0` is the initial position. `v` is the velocity. `t` is the elapsed time.

## General tips

### Set the MTU size to match your connection

The MTU size is the maximum packet size RakNet generates. If a single packet exceeds this, it is split at a significant performance cost. Multiple user packets are coalesced into a single larger packet, up to the MTU size. Increasing the MTU allows more user packets to be sent at once -- doubling the MTU can double bandwidth in certain conditions. However, if the MTU exceeds what any router along the network path supports, the network either fragments the packet or drops it. The default is 576 bytes (for modem users), ensuring universal compatibility. Broadband users should increase this via `SetMTUSize()` on both the client and the server. Set it according to the following chart:

-   1500. The largest Ethernet packet size. This is the typical setting for non-PPPoE, non-VPN connections. The default value for NETGEAR routers, adapters and switches.
-   1492. The size PPPoE prefers.
-   1472. Maximum size to use for pinging. (Bigger packets are fragmented.)
-   1468. The size DHCP prefers.
-   1460. Usable by AOL if large email attachments are not involved.
-   1430. The size VPN and PPTP prefer.
-   1400. Maximum size for AOL DSL.
-   576. Typical value to connect to dial-up ISPs.

### Send all the data, not just the changes

A certain level of redundancy is necessary because small errors accumulate. For example, sending the position once and then only sending keyboard input (thrust, stop thrusting, turn, stop turning) causes drift. Each input packet introduces a few milliseconds of timing error, and after 5-6 seconds the ship is at a noticeably different position on different machines.

The better approach:
Thrust and current position,
Stop thrusting and current position,
Turn and current position,
Stop turning and current position.

### Send data to only those who need it

If a player in your gameworld is 500 feet from another player whose visibility range is 300 feet, there is no need to send the distant player's actions. Only relay actions to systems that are affected by them.

### Use the correct packet type for the correct situation

<Callout type="info">
Reliable, ordered packets are convenient because you do not have to account for out-of-order events such as killing a monster that has not spawned yet. However, every reliable packet requires an acknowledgement, preventing resend. For very small packets this can double bandwidth usage, since the full UDP header is sent whether the payload is 1 byte or 400 bytes.
</Callout>

Here are some examples on when to use and when not to use particular types of packets:

**Chat messages** -- These must arrive. Use ordered and reliable.

**Position updates that are sent every 100 ms** -- Packetloss is typically only a few percent, so missing a packet is acceptable -- the next packet arrives soon and corrects the state. Unreliable sequenced works well here. Note that this assumes continuous sending. If sending stops at some point, the last packet(s) may never arrive, which could be a problem.

**Position updates that are sent every 2000 ms** -- If a packet is missed, the object appears stationary at an outdated position for an extended period. Reliable ordered is best.

**A declining number, such as health with no healing** -- Ordering does not matter; only sequencing matters, because older packets are always stale. If updates are frequent, unreliable sequenced is best. Otherwise, use reliable sequenced. If sending stops at some point (e.g., health reaches 0), use reliable sequenced. Otherwise the final packet may never arrive and the recipient still sees health greater than 0.

**A toggle switch** -- Only the number of activations matters, not the order. Reliable is most suitable.

**A frequent audio taunt with no gameplay impact** -- Delivery and ordering are both unimportant. Unreliable is most suitable.

---
title: "RakNet Tutorial"
description: "Hands-on tutorial for building a simple chat client and server with RakNet."
---

## Project setup

In this tutorial all images and interface references are for Visual Studio 2005, copyrighted by Microsoft. Use the equivalents for your own compiler.

<Steps>

<Step>

### Create a new Win32 Console Project

Name it ChatServer.

![](/images/tutorial1.jpg)

</Step>

<Step>

### Configure the project type

Make it a console application, and an empty project. Windows application is also acceptable.

![](/images/tutorial2.jpg)

</Step>

<Step>

### Add RakNet source files

Add the RakNet source files to your project. You can do this by right clicking on the project name, selecting Add, and then Existing Item from the rollout. Navigate to where you downloaded RakNet, navigate to the Source directory, hold down left shift, select the first file in the list, then click the last file in the list. Then press OK.

![](/images/tutorial3.jpg)

</Step>

<Step>

### Add a main file

Add a main file to your project. Do this by right clicking on the project name, selecting Add, and then new item. Under Visual C++ select code, then c++ file. Name the file main.cpp.

![](/images/tutorial4.jpg)

</Step>

<Step>

### Set the include path

Since the source files are in a directory other than the project, add that directory to the include search path to avoid typing out the full path in every `#include`. Right-click the "Chat Server" project name in the project tab. Select properties. In the top pane, change the drop down menu to "All Configurations." Select C/C++ / General / Additional Include Directories. Add the path to the Source directory of your RakNet download, and hit OK.

![](/images/tutorial5.jpg)

</Step>

<Step>

### Link ws2_32.lib

Next, link in ws2_32.lib, from the same dialog box.

![](/images/tutorial6.jpg)

</Step>

<Step>

### Change the character set

Also change the character set to not set. This is so regular array based strings are used, as opposed to unicode or wide character.

![](/images/tutorial7.jpg)

</Step>

<Step>

### Begin coding

You are ready to begin adding code to main.cpp.

</Step>

</Steps>

## Code implementation

### 1. Design

The chat server starts as basic as possible. It has two main modes: server and client. The server receives a client message. The client sends a message on startup. Most input variables are hardcoded to keep the code focused on networking.

### 2. First compile

Create your main function. Query the user as to whether they want to run a client or server. Create the peer instance, and call `Startup` with the appropriate parameters for a Server or Client. Destroy the peer at the end.

See [code sample 1](#tutorial-sample-1) below for the reference implementation.

<Callout type="warn">
Hit F7 or the equivalent to build. It should build successfully at this point. If it doesn't, refer to the [FAQ](/reference/faq) which gives many reasons for why something won't build and how to fix it.
</Callout>

### 3. Adding functionality

Now that the client and server are instantiated, explore the available API. The primary reference is `RakPeerInterface.h`, which contains all the functions for the class with detailed comments on each. Review the comments for the `Startup` and `Connect` functions, as well as `SetMaximumIncomingConnections`.

In the code, after the server was created, add code to start the server. That takes certain parameters - set whatever you wish, based on the description provided in the comments.

Do something similar with the client. After the code where it is created, add code to connect it. It takes an IP - add code to read an IP. For the server port, either put code to read the port, or hardcode the server port you entered above. For the client port, either put code to read it, or put 0 to automatically choose.

This is all that is needed to start a server or connect a client. To determine if the connection was successful, read messages from the network system. In `RakPeerInterface.h`, the `Receive` function returns a `Packet` structure, defined in `RakNetTypes.h`. It encapsulates one message and is straightforward.

The `char *data` member shows that all packets contain an array of bytes. These bytes can be anything you want. The length of the array is indicated by the `length` and `bitSize` fields. By convention, the first byte is always an identifier that tells you what the rest of the data is. These identifiers are defined in [MessageIdentifiers.h](/basics/network-messages).

There are many pre-defined enumerations. Read the comments on each of them. For now, only the connectivity enumerations matter. The next programming step is as follows:

1.  Create a loop for the main body of your program.
2.  In that loop, call `Receive` and store the pointer returned in a pointer variable of type `Packet`.
3.  If the packet variable is not 0 (which means no packets to read), check the first byte of `Packet::data`. See which of the connectivity related enumerations this byte matches (a switch/case would be handy here).
4.  Print out the comment that goes along with that enumeration.
5.  As specified in the comments, when you are done with the `Packet` pointer deallocate it by passing it to the `DeallocatePacket` method.

See [code sample 2](#tutorial-sample-2) below for the reference implementation.

At this point you should be able to run two instances (In Visual Studio, hit ctrl-F5 twice) and connect to each other. If you cannot connect, then refer to the [FAQ](/reference/faq).

Expected output from the sample:

**Server output**

```text
(C)lient or (S)erver?
s
Starting the server.
A connection is incoming.
```

**Client output**

```text
(C)lient or (S)erver?
c
Enter server IP or hit enter for 127.0.0.1
127.0.0.1
Starting the client.
Our connection request has been accepted.
```

The next step is to send input.
The next programming steps are:

1.  Add a user defined enumeration to send as the first byte of your game messages.
2.  When the client successfully connects, send a string using `RakString()`. Read it on the server, and print it out.

See [code sample 3](#tutorial-sample-3) below for the reference implementation.

The client output should be similar to before. The server output should also print "Hello World"

```text
(C)lient or (S)erver?
s
Starting the server.
A connection is incoming.
Hello World
```

See the index for a list of major systems not covered here. For further information on setting up your project, see the [Compiler setup](/getting-started/compiler-setup) page.

## Code samples

### Tutorial Sample 1

```cpp
#include "RakPeerInterface.h"
#include <stdio.h>

#define MAX_CLIENTS 10
#define SERVER_PORT 60000

int main(void) {
    char str[512];
    RakNet::RakPeerInterface *peer = RakNet::RakPeerInterface::GetInstance();
    bool isServer;

    printf("(C) or (S)erver?\n");
    gets(str);
    if ((str[0] == 'c') || (str[0] == 'C')) {
        RakNet::SocketDescriptor sd;
        peer->Startup(1, &sd, 1);
        isServer = false;
    } else {
        RakNet::SocketDescriptor sd(SERVER_PORT, 0);
        peer->Startup(MAX_CLIENTS, &sd, 1);
        isServer = true;
    }

    // TODO - Add code body here

    RakNet::RakPeerInterface::DestroyInstance(peer);

    return 0;
}
```
### Tutorial Sample 2

```cpp
#include "MessageIdentifiers.h"
#include "RakPeerInterface.h"
#include <stdio.h>
#include <string.h>

#define MAX_CLIENTS 10
#define SERVER_PORT 60000

int main(void) {
    char str[512];

    RakNet::RakPeerInterface *peer = RakNet::RakPeerInterface::GetInstance();
    bool isServer;
    RakNet::Packet *packet;

    printf("(C) or (S)erver?\n");
    gets(str);

    if ((str[0] == 'c') || (str[0] == 'C')) {
        RakNet::SocketDescriptor sd;
        peer->Startup(1, &sd, 1);
        isServer = false;
    } else {
        RakNet::SocketDescriptor sd(SERVER_PORT, 0);
        peer->Startup(MAX_CLIENTS, &sd, 1);
        isServer = true;
    }

    if (isServer) {
        printf("Starting the server.\n");
        // We need to let the server accept incoming connections from the
        // clients
        peer->SetMaximumIncomingConnections(MAX_CLIENTS);
    } else {
        printf("Enter server IP or hit enter for 127.0.0.1\n");
        gets(str);
        if (str[0] == 0) {
            strcpy(str, "127.0.0.1");
        }
        printf("Starting the client.\n");
        peer->Connect(str, SERVER_PORT, 0, 0);
    }

    while (1) {
        for (packet = peer->Receive(); packet;
             peer->DeallocatePacket(packet), packet = peer->Receive()) {
            switch (packet->data[0]) {
            case ID_REMOTE_DISCONNECTION_NOTIFICATION:
                printf("Another client has disconnected.\n");
                break;
            case ID_REMOTE_CONNECTION_LOST:
                printf("Another client has lost the connection.\n");
                break;
            case ID_REMOTE_NEW_INCOMING_CONNECTION:
                printf("Another client has connected.\n");
                break;
            case ID_CONNECTION_REQUEST_ACCEPTED:
                printf("Our connection request has been accepted.\n");
                break;
            case ID_NEW_INCOMING_CONNECTION:
                printf("A connection is incoming.\n");
                break;
            case ID_NO_FREE_INCOMING_CONNECTIONS:
                printf("The server is full.\n");
                break;
            case ID_DISCONNECTION_NOTIFICATION:
                if (isServer) {
                    printf("A client has disconnected.\n");
                } else {
                    printf("We have been disconnected.\n");
                }
                break;
            case ID_CONNECTION_LOST:
                if (isServer) {
                    printf("A client lost the connection.\n");
                } else {
                    printf("Connection lost.\n");
                }
                break;
            default:
                printf("Message with identifier %i has arrived.\n", packet->data[0]);
                break;
            }
        }
    }

    RakNet::RakPeerInterface::DestroyInstance(peer);

    return 0;
}
```
### Tutorial Sample 3

```cpp
#include "BitStream.h"
#include "MessageIdentifiers.h"
#include "RakNetTypes.h" // MessageID
#include "RakPeerInterface.h"
#include <stdio.h>
#include <string.h>

#define MAX_CLIENTS 10
#define SERVER_PORT 60000

enum GameMessages { ID_GAME_MESSAGE_1 = ID_USER_PACKET_ENUM + 1 };

int main(void) {
    char str[512];

    RakNet::RakPeerInterface *peer = RakNet::RakPeerInterface::GetInstance();
    bool isServer;
    RakNet::Packet *packet;

    printf("(C) or (S)erver?\n");
    gets(str);

    if ((str[0] == 'c') || (str[0] == 'C')) {
        RakNet::SocketDescriptor sd;
        peer->Startup(1, &sd, 1);
        isServer = false;
    } else {
        RakNet::SocketDescriptor sd(SERVER_PORT, 0);
        peer->Startup(MAX_CLIENTS, &sd, 1);
        isServer = true;
    }

    if (isServer) {
        printf("Starting the server.\n");
        // We need to let the server accept incoming connections from the
        // clients
        peer->SetMaximumIncomingConnections(MAX_CLIENTS);
    } else {
        printf("Enter server IP or hit enter for 127.0.0.1\n");
        gets(str);
        if (str[0] == 0) {
            strcpy(str, "127.0.0.1");
        }
        printf("Starting the client.\n");
        peer->Connect(str, SERVER_PORT, 0, 0);
    }

    while (1) {
        for (packet = peer->Receive(); packet;
             peer->DeallocatePacket(packet), packet = peer->Receive()) {
            switch (packet->data[0]) {
            case ID_REMOTE_DISCONNECTION_NOTIFICATION:
                printf("Another client has disconnected.\n");
                break;
            case ID_REMOTE_CONNECTION_LOST:
                printf("Another client has lost the connection.\n");
                break;
            case ID_REMOTE_NEW_INCOMING_CONNECTION:
                printf("Another client has connected.\n");
                break;
            case ID_CONNECTION_REQUEST_ACCEPTED: {
                printf("Our connection request has been accepted.\n");

                // Use a BitStream to write a custom user message
                // Bitstreams are easier to use than sending casted structures,
                // and handle endian swapping automatically
                RakNet::BitStream bsOut;
                bsOut.Write((RakNet::MessageID)ID_GAME_MESSAGE_1);
                bsOut.Write("Hello world");
                peer->Send(&bsOut, HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->systemAddress,
                           false);
            } break;
            case ID_NEW_INCOMING_CONNECTION:
                printf("A connection is incoming.\n");
                break;
            case ID_NO_FREE_INCOMING_CONNECTIONS:
                printf("The server is full.\n");
                break;
            case ID_DISCONNECTION_NOTIFICATION:
                if (isServer) {
                    printf("A client has disconnected.\n");
                } else {
                    printf("We have been disconnected.\n");
                }
                break;
            case ID_CONNECTION_LOST:
                if (isServer) {
                    printf("A client lost the connection.\n");
                } else {
                    printf("Connection lost.\n");
                }
                break;

            case ID_GAME_MESSAGE_1: {
                RakNet::RakString rs;
                RakNet::BitStream bsIn(packet->data, packet->length, false);
                bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
                bsIn.Read(rs);
                printf("%s\n", rs.C_String());
            } break;

            default:
                printf("Message with identifier %i has arrived.\n", packet->data[0]);
                break;
            }
        }
    }

    RakNet::RakPeerInterface::DestroyInstance(peer);

    return 0;
}
```

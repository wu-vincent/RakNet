---
title: "Reliability Types"
description: "Reference for PacketPriority and PacketReliability enums that control how and when packets are delivered over the network."
---

## Packet priority and reliability types

## PacketPriority

| Value | Description |
|-------|-------------|
| `IMMEDIATE_PRIORITY` | The highest possible priority. These messages trigger sends immediately, and are generally not buffered or aggregated into a single datagram. |
| `HIGH_PRIORITY` | For every 2 `IMMEDIATE_PRIORITY` messages, 1 `HIGH_PRIORITY` will be sent. Messages at this level and lower are buffered to be sent in groups at 10 millisecond intervals. |
| `MEDIUM_PRIORITY` | For every 2 `HIGH_PRIORITY` messages, 1 `MEDIUM_PRIORITY` will be sent. |
| `LOW_PRIORITY` | For every 2 `MEDIUM_PRIORITY` messages, 1 `LOW_PRIORITY` will be sent. |

`PacketPriority` is straightforward: high priority packets go out before medium priority packets, and medium priority packets go out before low priority packets. Raising the priority of packets that take a long time to send may seem logical, but in practice this disrupts games in progress as unimportant data to new connections (such as map data) interferes with game data.

## PacketReliability

| Value | Description |
|-------|-------------|
| `UNRELIABLE` | Sent by straight UDP. May arrive out of order, or not at all. Best for unimportant or frequently sent data. |
| `UNRELIABLE_SEQUENCED` | Same as unreliable, except that only the newest packet is ever accepted. Older packets are ignored. |
| `RELIABLE` | UDP packets monitored by a reliability layer to ensure they arrive at the destination. No ordering guarantee. |
| `RELIABLE_ORDERED` | Reliable and ordered at the destination. Easiest to program for â€” no worry about out-of-order or lost packets. |
| `RELIABLE_SEQUENCED` | Reliable and sequenced. You get reliability of UDP packets plus ordering, yet do not have to wait for old packets. |
| `UNRELIABLE_WITH_ACK_RECEIPT` | Unreliable with acknowledgment receipt notification on delivery or loss. |
| `UNRELIABLE_SEQUENCED_WITH_ACK_RECEIPT` | Unreliable sequenced with acknowledgment receipt notification. |
| `RELIABLE_WITH_ACK_RECEIPT` | Reliable with acknowledgment receipt notification on delivery. |
| `RELIABLE_ORDERED_WITH_ACK_RECEIPT` | Reliable ordered with acknowledgment receipt notification on delivery. |
| `RELIABLE_SEQUENCED_WITH_ACK_RECEIPT` | Reliable sequenced with acknowledgment receipt notification on delivery. |

<Callout type="warn">
The transmission of one of the three reliable packet types is required for the detection of lost connections. If you never send reliable packets you need to implement lost connection detection manually.
</Callout>

## Reliability type details

#### Unreliable
Unreliable packets are sent by straight UDP. They may arrive out of order, or not at all. This is best for unimportant data, or data sent frequently enough that newer packets compensate for missed ones.
Advantages - These packets do not need acknowledgment, saving the size of a UDP header per acknowledgment (roughly 50 bytes). The savings accumulate quickly.
Disadvantages - No packet ordering, packets may never arrive, and these packets are the first to be dropped if the send buffer is full.

#### Unreliable sequenced

Unreliable sequenced packets are the same as unreliable packets, except that only the newest packet is ever accepted. Older packets are ignored. Advantages - Same low overhead as unreliable packets, and older packets cannot revert your data to stale values.
Disadvantages - Many packets are dropped, both from UDP loss and from sequencing. These packets are the first to be dropped if the send buffer is full. The last packet sent may never arrive, which is problematic if you stop sending packets at a particular point.

#### Reliable
Reliable packets are UDP packets monitored by a reliability layer to ensure they arrive at the destination.
Advantages - You know the packet will get there. Eventually...
Disadvantages - Retransmissions and acknowledgments can add significant bandwidth requirements. Packets may arrive very late if the network is busy. No packet ordering.

#### Reliable ordered
Reliable ordered packets are UDP packets monitored by a reliability layer to ensure they arrive at the destination in order. Advantages - Packets arrive and in the order sent. These are the easiest to program for because out-of-order and lost packets are handled transparently.
Disadvantages - Retransmissions and acknowledgments can add significant bandwidth requirements. Packets may arrive late if the network is busy. One late packet can delay many packets that arrived sooner, resulting in significant lag spikes. However, this disadvantage can be mitigated by careful use of ordering streams.

#### Reliable sequenced
Reliable sequenced packets are UDP packets monitored by a reliability layer to ensure they arrive at the destination and are sequenced at the destination.
Advantages - You get the reliability of UDP packets and the ordering of ordered packets, yet do not have to wait for old packets. More packets arrive with this method than with unreliable sequenced, and they are distributed more evenly. The most important advantage is that the latest packet sent is guaranteed to arrive, unlike unreliable sequenced where it may not.
Disadvantages - Wasteful of bandwidth because it uses the overhead of reliable UDP packets to ensure late packets arrive that are then ignored.

## Acknowledgment receipts

`*_WITH_ACK_RECEIPT`

By specifying one of the `PacketReliability` types that contain `_WITH_ACK_RECEIPT`, you can request that `RakPeerInterface` notify you when a message has been acknowledged by the remote system, or delivery has timed out.

Calls to `RakPeerInterface::Send()` or `RakPeerInterface::SendLists()` return a 4 byte unsigned integer representing an ID for the message sent. When using `_WITH_ACK_RECEIPT`, this same ID will be returned to you when you call `RakPeerInterface::Receive()`. In the packet, byte 0 will be either `ID_SND_RECEIPT_ACKED` or `ID_SND_RECEIPT_LOSS`. Bytes 1-4 inclusive will contain the same number returned to you from `Send()` or `SendLists()`.

`ID_SND_RECEIPT_ACKED` means that the message arrived. For reliable sends, this is all you will ever get.

`ID_SND_RECEIPT_LOSS` is only returned for `UNRELIABLE_WITH_ACK_RECEIPT` and `UNRELIABLE_SEQUENCED_WITH_ACK_RECEIPT`. It means that an ack for the message did not arrive within the threshold given for message resends (roughly a multiple of your ping). It could mean any of the following:

-   The message was lost in transmission
-   The message arrived, but the ack was lost in transmission
-   The message arrived, and the ack arrived, but arrived later than the threshold (a ping spike)

It usually means one of the first two.

Example of reading the return receipt:

```cpp
packet = rakPeer->Receive();
while (packet) {
    switch (packet->data[0]) {
    case ID_SND_RECEIPT_ACKED:
        memcpy(&msgNumber, packet->data + 1, 4);
        printf("Msg #%i was delivered.\n", msgNumber);
        break;
    case ID_SND_RECEIPT_LOSS:
        memcpy(&msgNumber, packet->data + 1, 4);
        printf("Msg #%i was probably not delivered.\n", msgNumber);
        break;
    }
    sender->DeallocatePacket(packet);
    packet = sender->Receive();
}
```

The typical use case is to determine whether unreliable messages arrived. Sometimes you want to resend unreliable messages with more up-to-date data, rather than relying on `RELIABLE` to resend the original data until it arrives. To do so, when you send unreliable data, create an internal mapping between the number returned by `Send()` or `SendLists()` and reference that number when the return receipt arrives. If the receipt is `ID_SND_RECEIPT_LOSS`, resend the message with current values.

## Advanced send types

**Send most recent values on resends**

When RakNet resends a message, it can only send the original data. For data that changes continually (position, for example), you may want to resend only the most recent value. To do so, send the data using `UNRELIABLE_WITH_ACK_RECEIPT`. Call `RakPeer::GetNextSendReceipt()` and pass the value to `RakPeer::Send()`. Store an association in memory between the message type and the send receipt. If you get `ID_SND_RECEIPT_ACKED`, delete the association (the message was delivered). If you get `ID_SND_RECEIPT_LOSS`, resend the message using the most current values.

If you also want the data to be sequenced, write your own sequence number along with the message. The remote side stores the highest sequence number received. If an incoming message has a lower sequence number than the highest received, it is an old message and can be ignored.

Here is code using an unsigned char sequence number. It will work as long as you do not send more than 127 messages out of order:

```cpp
typedef unsigned char SequenceNumberType;

bool GreaterThan(SequenceNumberType a, SequenceNumberType b) {
    // a > b?
    const SequenceNumberType halfSpan =
        (SequenceNumberType)(((SequenceNumberType)(const SequenceNumberType)-1) /
                             (SequenceNumberType)2);
    return b != a && b - a > halfSpan;
}
```

_Sequenced data, rather than sequenced messages_

RakNet's sequencing only works on the entire message. However, sometimes you want to sequence data at a higher level of granularity. For example, suppose you had both position and health sequenced.

Message A contains health
Message B contains both health and position
Message C contains position

Using normal sequencing, if the messages arrived in the order A,C,B, message B would be discarded. However, you lose useful information, since message B contains a more recent health value and could have been used.

You can subsequence on data manually by writing your own sequence number per variable that you are serializing (as described above). Then send the data using a non-sequenced send type depending on your needs, `UNRELIABLE`, `UNRELIABLE_WITH_ACK_RECEIPT`, `RELIABLE`, etc. While this does incur more bandwidth and processing overhead, it has the advantage that every update can be processed as soon as possible.

---
title: "Console Server"
description: Remotely control a game server via Telnet or secure RakNet transport.
---

Controlling a server remotely is necessary when the host is located offsite, or when you need to manage multiple servers via scripts. `ConsoleServer`, `CommandParserInterface`, and `TransportInterface` are three classes that work together to address these needs.

## Architecture

**ConsoleServer**

`ConsoleServer`, located at `ConsoleServer.h`, holds a list of `CommandParserInterface` instances added with `ConsoleServer::AddCommandParser()`. Calling `ConsoleServer::Update()` once per game tick processes all registered `CommandParserInterface` instances for incoming input.

**CommandParserInterface**

A command parser operates on a named set of registered commands. `CommandParserInterface` is the base class from which you derive functionality for each command parser. For example, `RakNetCommandParser.h` exposes most functions available in `RakPeerInterface`. `RakNetTransportCommandParser` exposes functions for the `RakNetTransport` class, which handles the underlying data transport for `ConsoleServer`.

**TransportInterface**

`TransportInterface` provides the `ConsoleServer` with string transport capabilities. Two implementations exist: `TelnetTransport` and `RakNetTransport`. `TelnetTransport` uses [TCPInterface](/utilities/tcp-interface) to reply to a remote telnet terminal. `RakNetTransport` sends strings through an instance of `RakPeer` with [secure connections](/basics/secure-connections) enabled.

## Putting It All Together

Excerpts from the sample `CommandConsoleServer`:

```cpp
ConsoleServer consoleServer;
TelnetTransport tt;
RakNetCommandParser rcp;
LogCommandParser lcp;
```

```cpp
consoleServer.AddCommandParser(&rcp);
consoleServer.AddCommandParser(&lcp);
consoleServer.SetTransportProvider(ti, port);
lcp.AddChannel("TestChannel");
```

```cpp
while (1) {
    lcp.WriteLog("TestChannel", "Test of logger");
    consoleServer.Update();
    // Game loop here
}
```

The setup requires one `ConsoleServer` instance, one transport interface (`TelnetTransport` or `RakNetTransport`), and your command parsers. Call `ConsoleServer::AddCommandParser` for each parser, `ConsoleServer::SetTransportProvider()` for telnet or RakNet, and `ConsoleServer::Update()` once per tick. This example also adds an output channel to `LogCommandParser` and writes to the log once per tick.

Assuming the server is already started, you can connect as follows:

**Start telnet from the start menu**
![Start Telnet](/images/telnet1.jpg)

**Connect to your server with telnet**
![Connect to localhost](/images/telnet2.jpg)

**The system should handle everything else**
![Help](/images/telnet3.jpg)

## RakNetTransport

### Secure Console Connections

Telnet is convenient but not secure. To send passwords or other sensitive data, use `RakNetTransport` on the server instead. This includes an additional command parser, `RakNetTransportCommandParser`, which provides the ability to change the password on the `RakPeer` instance internal to `RakNetTransport`. This design allows remote users to connect to the command parser without connecting to the game itself, enabling different passwords for the game and the command parser.

For the client-side, the sample `CommandConsoleClient` is an implementation of a console application that uses RakNet to connect to `RakNetTransport`.

## Creating Your Own Command Parser

To add a new command parser, derive a class from `CommandParserInterface`, as done in `RakNetCommandParser.h`. Override `OnCommand`, `GetName`, and `SendHelp`. Add any additional functionality needed to communicate with your game, such as `SetGamePointer()` or `SetLogger()`.

<Steps>

<Step>

### Register commands

In the constructor of your new class, call `RegisterCommand` for each command. Example from `RakNetCommandParser.cpp`:

```cpp
RegisterCommand(4,
                "Startup",
                "( unsigned short maxConnections, int _threadSleepTimer, "
                "unsigned short localPort, const char *forceHostAddress );");
```

The first parameter (`4`) is the number of parameters to pass to the function. The second parameter (`"Startup"`) is the name of the command and appears in the abbreviated command list. The third parameter defines the `helpString`, displayed when help is called on a particular named command.

With this syntax, `ConsoleServer` verifies the correct number of parameters and returns an error to the user if the count does not match.

</Step>

<Step>

### Implement OnCommand

In `OnCommand()`, compare the command string to your registered commands, and take the desired action:

```cpp
if (strcmp(command, "Startup") == 0) {
    SocketDescriptor socketDescriptor((unsigned short)atoi(parameterList[1]), parameterList[3]);
    ReturnResult(peer->Startup((unsigned short)atoi(parameterList[0]), atoi(parameterList[2]),
                               &socketDescriptor, 1),
                 command, transport, systemAddress);
}
```

The return value of `OnCommand` is currently unused; return `true`. `ReturnResult` is an optional helper that sends a string back to the requesting system.

</Step>

<Step>

### Implement GetName

Return the name of your command parser. This appears in the command parser listing.

</Step>

<Step>

### Implement SendHelp

Return extended help when queried for your particular parser. If the parser is not runnable due to failed preconditions, return a notification message here.

</Step>

</Steps>

## Advanced Options

**Unknown or variable number of parameters:**

Pass `CommandParserInterface::VARIABLE_NUMBER_OF_PARAMETERS` as the first parameter to `RegisterCommand`. `ConsoleServer` skips parameter count validation in this case. Handle error conditions in `OnCommand()` yourself.

**Direct string parsing:**

If you do not want `ConsoleServer` to parse the incoming string, use the `originalString` parameter passed to `OnCommand`. For example, when controlling a scripting system, pass this string directly to the script interpreter.

**Changing delimiters:**

To use a different command delimiter than space, or a different string delimiter than quotation marks, modify the defines in `CommandServer.cpp`:

```cpp
#define COMMAND_DELINATOR ' '
#define COMMAND_DELINATOR_TOGGLE '"'
```

---
title: "RakVoice"
description: "Transmit real-time voice communication at low bandwidth using the RakVoice plugin with Speex encoding."
---

## Real-time voice communication

`RakVoice` is a feature of RakNet that allows real time voice communication at a cost of only ~2200 bytes per second at 8000 16 bit samples per second. It uses Speex (http://www.speex.org/) to do the encoding. `RakVoice` is a plugin class that makes it easier to encode, send, decode, and relay raw sound data.

<Callout type="warn">
`RakVoice` is not part of the RakNet core, so you'll need to add it to your project separately.
</Callout>

To get an instance of `RakVoice`, allocate one with `new` or use a global object.

```cpp
RakVoice rakVoice;
```

Since `RakVoice` is a plugin, you need to attach it to a peer.

```cpp
rakPeer->AttachPlugin(&rakVoice);
```

Initialize the class with the sample rate and the size of the buffer to process. A buffer size of 512 bytes is a reasonable value when using frequencies of 8000 Hz.
The buffer size is the number of bytes to encode at a time, and the number of bytes returned by the decoder. This is normally the same size you lock the sound buffer by. Encoding reduces the packet size by about 75%.

```cpp
rakVoice.Init(8000, 512);
```

When data comes in on the sound buffer from the microphone, call `SendFrame`, passing the `SystemAddress` of the recipient system and a pointer to the buffer to encode. Unlike normal API send calls, you cannot broadcast voice packets because each encoder and decoder is a matched pair. Therefore, you must always specify the `SystemAddress` so the sender knows which encoder to use. To broadcast, send to each recipient individually. Note that the size of the input buffer must match the buffer size set earlier. For example:

```cpp
rakVoice.SendFrame(recipientSystemAddress, (char *)inputBuffer);
```

On the receiving system, depending on the sound engine, you likely have a circular sound buffer that you feed with decoded data from `RakVoice`. Every time your sound engine needs data to play, call `ReceiveFrame`. It writes a buffer of sound at the passed pointer, or silence if no new data is available. The data returned has the same size you specified in `Init` (see above).

```cpp
rakVoice.ReceiveFrame((char *)outbuffer);
```

The last point of note is that `RakVoice` requires all clients in a chat session to be aware of all other clients' connection states. The reasons for this are:

-   You need to call `SendFrame` with a specific recipient for broadcasting.
-   You may want to call `CloseVoiceChannel`, to stop communications with a particular system.


`RakVoice` only provides a means to encode and decode raw sound data and to communicate over the network. It does not include a mechanism to play or record sound. Two samples demonstrate how to integrate with sound engines:

_\\Samples\\RakVoiceFMOD_ - Provides a class to integrate `RakVoice` with the [FMOD](http://www.fmod.org/) sound engine.
_\\Samples\\RakVoice_ - Demonstrates how to integrate `RakVoice` with the free and open-source PortAudio sound engine.

<Callout type="info">
The source to PortAudio (http://www.portaudio.com/) and Speex (http://www.speex.org/) are included in RakNet and can be found in the root directory for rebuilding on other platforms. These are independent open-source APIs and are not owned by the RakNet authors. Please refer to the respective webpages for more information on these APIs and the included license agreements.
</Callout>

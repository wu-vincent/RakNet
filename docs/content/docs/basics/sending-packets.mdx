---
title: "Sending Packets"
description: "How to send packets using RakNet, including choosing data authority, reliability types, and ordering streams."
---

## Step 1: Determine your data

As covered in [Creating Packets](/basics/creating-packets), determine what data you need and whether to use a bitstream or a struct.

## Step 2: Determine the authority

Send the trigger for an action rather than continually sending the result. The source of a packet falls under three categories:

- _From the function that does the action_
- _From the trigger to the function that does the action_
- _From a data monitor_

Each method has advantages and disadvantages.

From the function that does the action:

**Example:**
Suppose you have a function `ShootBullet` that takes parameters such as type of shot, shot origin, and shot direction. Every time `ShootBullet` is entered, you send a packet to tell the network that this happened.

**Advantage:**
Easy to maintain. `ShootBullet` may be called from many different places (mouse input, keyboard input, AI) and you do not need to track every place it gets sent from. Easy to implement into existing single-player games.

**Disadvantage:**
Hard to program. If `ShootBullet` initiates the packet, what does the network call when it wants to perform this function? If `ShootBullet` initiates the packet and the network calls `ShootBullet`, another packet gets sent, creating a feedback loop. You can either write another function like `DoShootBullet` (sloppy), or pass a parameter to `ShootBullet` indicating whether to send a packet. You also need to consider authority. Can the client shoot the bullet immediately, or does it need authorization from the server first? If authorization is required, `ShootBullet` should send a packet and return immediately -- unless the network called it, in which case it should skip the packet and perform the action instead. The network may also need additional data that `ShootBullet` does not have, such as the number of bullets remaining. Sometimes you can get this from context, sometimes not. It takes practice and experience to code in this style.

From the trigger to the function that does the action:

**Example:**
Using the `ShootBullet` example again: this time, rather than sending the packet from inside `ShootBullet`, you send the packet from the trigger to `ShootBullet` -- for example, when the user clicks the mouse, the AI decides to shoot, or the spacebar is pressed.

**Advantage:**
You can call the `ShootBullet` function from the network without worrying about feedback loops. You also generally have more information available from outside the function, making it easier to send additional data if the network needs it.

**Disadvantage:**
High maintenance. If you later add another way to shoot bullets, you may forget to send a packet for it.

From a data monitor:

**Example:**
Every time a player's health reaches 0, send a packet. However, do not do this at the point where health actually reaches 0. Instead, add it to a function that runs every frame, perhaps in the player update code. When this code detects health at 0 for the first time, it sends a packet and records that the packet was sent so it is not sent again.

**Advantage:**
Very clean from a networking perspective. No feedback concerns, and no changes to the function that does the action. No maintenance unless someone changes the monitored data. Enables network efficiency algorithms such as "do not send this packet more than once per second."

**Disadvantage:**
Sloppy from a design point of view. Can only be used for certain types of data. Extra work to reset monitoring code when the object you are monitoring is reset. Requires that other programmers in the project know about it in case they decide to change how the data you are monitoring works.

## Step 3: Determine the reliability type and ordering stream

`PacketPriority.h` contains the enums for these. You have four priorities to choose from: `IMMEDIATE_PRIORITY`, `HIGH_PRIORITY`, `MEDIUM_PRIORITY`, `LOW_PRIORITY`

Each priority is sent approximately twice as often as the priority below it. So for example, if you send 2 messages `HIGH_PRIORITY` and at a similar time send another message `IMMEDIATE_PRIORITY`, the odds are the `IMMEDIATE_PRIORITY` will arrive first, although this is not guaranteed.

Reliability types are covered in the [Detailed Implementation](/getting-started/detailed-implementation). For most games, use `RELIABLE_ORDERED` packets. For all ordered types, pick an ordering stream as described below.

## Step 4: Call the `Send` function in `RakPeerInterface.h`

The send method does not modify your data and makes a copy internally, so no further action is required on your part.

**Ordering streams**

<Callout type="info">
There are 32 ordering streams available for ordered packets and 32 ordering streams available for sequenced packets. You can think of the stream as a relative ordering stream, where all packets of the same ordering type are ordered relative to each other. Packets in different ordering streams are independent and will not wait on each other.
</Callout>

An example illustrates this best. Suppose you want to order all chat messages, order all player movement packets, order all player firing packets, and sequence all remaining ammunition packets. Chat messages should arrive in order, but a chat message should not be held up because a player movement packet sent earlier has not yet arrived. Player movement packets have no relation to chat messages, so their relative arrival order is irrelevant. Use different ordering streams for them -- perhaps 0 for chat messages and 1 for player movement packets. However, suppose player firing packets must be ordered relative to player movement packets because you do not want the shot to originate from the wrong position. Put player firing packets on the same stream as movement packets (stream 1), so that if a movement packet arrived later than a firing packet but was actually sent earlier, the firing packet is not delivered to you until the movement packet arrives.

Sequenced packets drop older packets: if you receive packet 2, then 1, then 3, the result is that you receive 2, packet 1 is dropped, and you receive 3. This is useful for ammunition because ammunition only decreases. An older packet would incorrectly raise the ammunition count. Since sequenced packets use a different set of streams than ordered packets, you can use any stream number you want, such as 0. This has no relation to chat messages because chat messages use the ordered stream set rather than the sequenced stream set.

Packets that are neither ordered nor sequenced (`UNRELIABLE` and `RELIABLE`) have no bearing on sequences. The ordering stream parameter is ignored by the send function for those packet types.
